{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Introduction TINerator is a tool for the fast creation of extruded and refined meshes from DEM and GIS data, developed at Los Alamos National Laboratory to aid in hydrogeological simulations. TINerator allows a user to define a bounding box of latitude/longitude coordinates, a shapefile, or a local DEM, and generate a surface or volume mesh. The mesh will have the topology of the DEM, along with user-defined material IDs and depths for stacked layers. Further, TINerator performs watershed delination on the defined DEM and refines the mesh\u2019s elements around the feature to a user-defined length scale. TINerator comes with a host of 2D and 3D visualization functions, allowing the user to view the status of the mesh at every step in the workflow. In addition, there are geometrical tools for removing triangles outside of a polygon, generating quality analytics on the mesh, adding cell- and node-based attributes to a mesh, and much more.","title":"Introduction"},{"location":"index.html#introduction","text":"TINerator is a tool for the fast creation of extruded and refined meshes from DEM and GIS data, developed at Los Alamos National Laboratory to aid in hydrogeological simulations. TINerator allows a user to define a bounding box of latitude/longitude coordinates, a shapefile, or a local DEM, and generate a surface or volume mesh. The mesh will have the topology of the DEM, along with user-defined material IDs and depths for stacked layers. Further, TINerator performs watershed delination on the defined DEM and refines the mesh\u2019s elements around the feature to a user-defined length scale. TINerator comes with a host of 2D and 3D visualization functions, allowing the user to view the status of the mesh at every step in the workflow. In addition, there are geometrical tools for removing triangles outside of a polygon, generating quality analytics on the mesh, adding cell- and node-based attributes to a mesh, and much more.","title":"Introduction"},{"location":"about.html","text":"About TINerator Funding TINerator is a collaborative effort between Los Alamos National Laboratory and Lawrence Berkeley National Laboratory. Development of TINerator is sponsored in part by the NGEE Arctic and DOE IDEAS programs. Development Team Daniel Livingston (EES-16; Los Alamos National Laboratory) David Moulton (T-5; Los Alamos National Laboratory) Ilhan Ozgen (CESD; Lawrence Berkeley National Laboratory) Zexuan Xu (CESD; Lawrence Berkeley National Laboratory) Richard Middleton (EES-16; Los Alamos National Laboratory) Terry Miller (EES-16; Los Alamos National Laboratory) Carl Gable (EES-16; Los Alamos National Laboratory) Contact Contact livingston@lanl.gov with questions and issues. License TINerator is licensed under the BSD-3 license. Click here to visit the license page .","title":"About"},{"location":"about.html#about-tinerator","text":"","title":"About TINerator"},{"location":"about.html#funding","text":"TINerator is a collaborative effort between Los Alamos National Laboratory and Lawrence Berkeley National Laboratory. Development of TINerator is sponsored in part by the NGEE Arctic and DOE IDEAS programs.","title":"Funding"},{"location":"about.html#development-team","text":"Daniel Livingston (EES-16; Los Alamos National Laboratory) David Moulton (T-5; Los Alamos National Laboratory) Ilhan Ozgen (CESD; Lawrence Berkeley National Laboratory) Zexuan Xu (CESD; Lawrence Berkeley National Laboratory) Richard Middleton (EES-16; Los Alamos National Laboratory) Terry Miller (EES-16; Los Alamos National Laboratory) Carl Gable (EES-16; Los Alamos National Laboratory)","title":"Development Team"},{"location":"about.html#contact","text":"Contact livingston@lanl.gov with questions and issues.","title":"Contact"},{"location":"about.html#license","text":"TINerator is licensed under the BSD-3 license. Click here to visit the license page .","title":"License"},{"location":"contributing.html","text":"Contributing How to Contribute Contribution Requirements Pull requests for missing features, bug fixes, and documentation updates are more than welcome. To contribute, please submit a pull request at https://github.com/lanl/LaGriT To ensure the best chance of acceptance for your pull request, please ensure that: All tests pass Your code is well documented and commented If adding new functionality, that unit tests have been included in the PR That the purpose and scope of your contributions are well explained in the PR Need an Issue? Visit the Issues page of LaGriT and search for tag 'Good First Issue'. These are great issues for someone unfamiliar with the codebase to work on. Function Docstrings API documentation is generated using the pydoc-markdown package. Proper formatting is explained in the Syntax section of their documentation. As an example of proper formatting, def some_function ( self , required_param : str , opt_1 : str = None , opt_2 : int = 34 ): ''' Some function documentation. # Arguments required_param (str): Some description. # Optional Arguments opt_1 (str,None): Some description. # Raises ValueError: If *opt_1* does not end with `.md`. # Returns The object that is returned. ''' Contributor License Agreement (CLA) If you are an external (non-LANL or LBNL) contributor, then in order to accept your pull request, we need you to submit a CLA. This license is for your protection as a Contributor as well as the protection of LANL and LaGriT users; it does not change your rights to use your own Contributions for any other purpose. Sign the CLA here: https://www.clahub.com/agreements/lanl/LaGriT License By contributing to TINerator, you agree that your contributions will be licensed under the BSD-3 license.","title":"Contributing"},{"location":"contributing.html#contributing","text":"","title":"Contributing"},{"location":"contributing.html#how-to-contribute","text":"","title":"How to Contribute"},{"location":"contributing.html#contribution-requirements","text":"Pull requests for missing features, bug fixes, and documentation updates are more than welcome. To contribute, please submit a pull request at https://github.com/lanl/LaGriT To ensure the best chance of acceptance for your pull request, please ensure that: All tests pass Your code is well documented and commented If adding new functionality, that unit tests have been included in the PR That the purpose and scope of your contributions are well explained in the PR","title":"Contribution Requirements"},{"location":"contributing.html#need-an-issue","text":"Visit the Issues page of LaGriT and search for tag 'Good First Issue'. These are great issues for someone unfamiliar with the codebase to work on.","title":"Need an Issue?"},{"location":"contributing.html#function-docstrings","text":"API documentation is generated using the pydoc-markdown package. Proper formatting is explained in the Syntax section of their documentation. As an example of proper formatting, def some_function ( self , required_param : str , opt_1 : str = None , opt_2 : int = 34 ): ''' Some function documentation. # Arguments required_param (str): Some description. # Optional Arguments opt_1 (str,None): Some description. # Raises ValueError: If *opt_1* does not end with `.md`. # Returns The object that is returned. '''","title":"Function Docstrings"},{"location":"contributing.html#contributor-license-agreement-cla","text":"If you are an external (non-LANL or LBNL) contributor, then in order to accept your pull request, we need you to submit a CLA. This license is for your protection as a Contributor as well as the protection of LANL and LaGriT users; it does not change your rights to use your own Contributions for any other purpose. Sign the CLA here: https://www.clahub.com/agreements/lanl/LaGriT","title":"Contributor License Agreement (CLA)"},{"location":"contributing.html#license","text":"By contributing to TINerator, you agree that your contributions will be licensed under the BSD-3 license.","title":"License"},{"location":"install.html","text":"Installation While TINerator is a relatively light module, it depends on several compiled libraries and packages. Consequently, it is recommended that you set up a Conda environment or virtual-env for managing TINerator: $ conda create --name tinerator python = 3 .5 $ source activate tinerator Note that you will have to re-run the source activate command on each new shell instance. Python Requirements TINerator requires Python 3.4+ and the following Python modules: Module URL RichDEM https://richdem.readthedocs.io Matplotlib https://matplotlib.org Numpy http://www.numpy.org SciPy https://www.scipy.org Rasterio https://rasterio.readthedocs.io Fiona https://fiona.readthedocs.io Elevation http://elevation.bopen.eu/en/stable/ PyLaGriT https://lanl.github.io/LaGriT/pylagrit/original/index.html With the exception of PyLaGriT, all modules will be automatically installed when running the python setup.py install command in TINerator. Warning On macOS, the default clang C/C++ compilers seem to fail on compilation of richdem . To circumvent this, export CC; export CXX to GNU GCC compilers. Building LaGriT + Exodus LaGriT is a mesh generation software suite built by Los Alamos National Laboratories, and it (wrapped by the Python library PyLaGriT) is the 'engine' driving TINerator. A LaGriT binary needs to be present on your system before proceeding. You can directly download a pre-built binary, or to build one yourself, run: git clone https://github.com/lanl/LaGriT.git && cd LaGriT make exodus make static && make test You will find the LaGriT executable in $( LAGRIT_ROOT_DIR ) /src/lagrit . For more information, please see the LaGriT installation documentation . Warning LaGriT does not currently support Windows compilation. Windows support is coming soon. Installing PyLaGriT PyLaGriT is a subfolder within the LaGriT repo. Navigate to $( LAGRIT_ROOT_DIR ) /PyLaGriT and run python setup.py install Next, create the file ~/.pylagritrc with the following text: lagrit_exe : 'path/to/lagrit/executable' where path/to/lagrit/executable is the path to the recently downloaded/installed LaGriT binary. For more information, visit the PyLaGriT installation page . Installing TINerator TINerator is currently a submodule within a branch on the LaGriT repository. Navigate to $( LAGRIT_ROOT_DIR ) and run git checkout tinerator cd tinerator python setup.py install TINerator should now be installed and ready for use. If you experience any difficulty building TINerator, please open an issue on the LaGriT Issues page . Installing MkDocs (Optional) Markdown files in the docs/ folder can be viewed with MkDocs. Build the following packages: pip install mkdocs pymdown-extensions mkdocs-material pygments pydoc-markdown and run, in the root directory of tinerator, mkdocs serve For more information, see Developer Notes . Next Steps Check out Examples to get started, or read the API for function and method documentation.","title":"Installation"},{"location":"install.html#installation","text":"While TINerator is a relatively light module, it depends on several compiled libraries and packages. Consequently, it is recommended that you set up a Conda environment or virtual-env for managing TINerator: $ conda create --name tinerator python = 3 .5 $ source activate tinerator Note that you will have to re-run the source activate command on each new shell instance.","title":"Installation"},{"location":"install.html#python-requirements","text":"TINerator requires Python 3.4+ and the following Python modules: Module URL RichDEM https://richdem.readthedocs.io Matplotlib https://matplotlib.org Numpy http://www.numpy.org SciPy https://www.scipy.org Rasterio https://rasterio.readthedocs.io Fiona https://fiona.readthedocs.io Elevation http://elevation.bopen.eu/en/stable/ PyLaGriT https://lanl.github.io/LaGriT/pylagrit/original/index.html With the exception of PyLaGriT, all modules will be automatically installed when running the python setup.py install command in TINerator. Warning On macOS, the default clang C/C++ compilers seem to fail on compilation of richdem . To circumvent this, export CC; export CXX to GNU GCC compilers.","title":"Python Requirements"},{"location":"install.html#building-lagrit-exodus","text":"LaGriT is a mesh generation software suite built by Los Alamos National Laboratories, and it (wrapped by the Python library PyLaGriT) is the 'engine' driving TINerator. A LaGriT binary needs to be present on your system before proceeding. You can directly download a pre-built binary, or to build one yourself, run: git clone https://github.com/lanl/LaGriT.git && cd LaGriT make exodus make static && make test You will find the LaGriT executable in $( LAGRIT_ROOT_DIR ) /src/lagrit . For more information, please see the LaGriT installation documentation . Warning LaGriT does not currently support Windows compilation. Windows support is coming soon.","title":"Building LaGriT + Exodus"},{"location":"install.html#installing-pylagrit","text":"PyLaGriT is a subfolder within the LaGriT repo. Navigate to $( LAGRIT_ROOT_DIR ) /PyLaGriT and run python setup.py install Next, create the file ~/.pylagritrc with the following text: lagrit_exe : 'path/to/lagrit/executable' where path/to/lagrit/executable is the path to the recently downloaded/installed LaGriT binary. For more information, visit the PyLaGriT installation page .","title":"Installing PyLaGriT"},{"location":"install.html#installing-tinerator","text":"TINerator is currently a submodule within a branch on the LaGriT repository. Navigate to $( LAGRIT_ROOT_DIR ) and run git checkout tinerator cd tinerator python setup.py install TINerator should now be installed and ready for use. If you experience any difficulty building TINerator, please open an issue on the LaGriT Issues page .","title":"Installing TINerator"},{"location":"install.html#installing-mkdocs-optional","text":"Markdown files in the docs/ folder can be viewed with MkDocs. Build the following packages: pip install mkdocs pymdown-extensions mkdocs-material pygments pydoc-markdown and run, in the root directory of tinerator, mkdocs serve For more information, see Developer Notes .","title":"Installing MkDocs (Optional)"},{"location":"install.html#next-steps","text":"Check out Examples to get started, or read the API for function and method documentation.","title":"Next Steps"},{"location":"license.html","text":"License (BSD) Copyright \u00a9 2019, Triad National Security, LLC. All rights reserved. Copyright 2019. Triad National Security, LLC. This software was produced under U.S. Government contract DE-AC52-06NA25396 for Los Alamos National Laboratory (LANL), which is operated by Triad National Security, LLC for the U.S. Department of Energy. The U.S. Government has rights to use, reproduce, and distribute this software. NEITHER THE GOVERNMENT NOR TRIAD NATIONAL SECURITY, LLC MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LIABILITY FOR THE USE OF THIS SOFTWARE. If software is modified to produce derivative works, such modified software should be clearly marked, so as not to confuse it with the version available from LANL. Additionally, redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of Triad National Security, LLC, Los Alamos National Laboratory, LANL, the U.S. Government, nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY TRIAD NATIONAL SECURITY, LLC AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL TRIAD NATIONAL SECURITY, LLC OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"license.html#license-bsd","text":"Copyright \u00a9 2019, Triad National Security, LLC. All rights reserved. Copyright 2019. Triad National Security, LLC. This software was produced under U.S. Government contract DE-AC52-06NA25396 for Los Alamos National Laboratory (LANL), which is operated by Triad National Security, LLC for the U.S. Department of Energy. The U.S. Government has rights to use, reproduce, and distribute this software. NEITHER THE GOVERNMENT NOR TRIAD NATIONAL SECURITY, LLC MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LIABILITY FOR THE USE OF THIS SOFTWARE. If software is modified to produce derivative works, such modified software should be clearly marked, so as not to confuse it with the version available from LANL. Additionally, redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of Triad National Security, LLC, Los Alamos National Laboratory, LANL, the U.S. Government, nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY TRIAD NATIONAL SECURITY, LLC AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL TRIAD NATIONAL SECURITY, LLC OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License (BSD)"},{"location":"release_notes.html","text":"Release Notes 0.3.0 (01/25/19) - Massive documentation updates 0.2.0 (DATE) - Full change from LaGriT infiles to PyLaGriT syntax 0.1.1 (08/12/18) - Minor bug fixes and beginning of documentation. 0.1.0 (08/10/18) - Initial release.","title":"Release Notes"},{"location":"release_notes.html#release-notes","text":"0.3.0 (01/25/19) - Massive documentation updates 0.2.0 (DATE) - Full change from LaGriT infiles to PyLaGriT syntax 0.1.1 (08/12/18) - Minor bug fixes and beginning of documentation. 0.1.0 (08/10/18) - Initial release.","title":"Release Notes"},{"location":"api/index.html","text":"tinerator loadDEM loadDEM ( filepath : str , lagrit_exe : str = None ) Loads a DEM raster from a local filepath and returns a tinerator.DEM instance. Attributes filepath (str) : Filepath to DEM raster lagrit_exe (str,None) : Optional filepath to LaGriT binary. If PyLaGriT is configured correctly, this should be unnecessary. DEM DEM ( self , filepath : str , lagrit_exe : str = None ) This is the 'main' class of TINerator, and stores all DEM and GIS data related to a particular project. Attributes filepath (str) : Filepath to DEM raster lagrit_exe (str,None) : Optional filepath to LaGriT binary. If PyLaGriT is configured correctly, this should be unnecessary. change_ndv DEM . change_ndv ( self , ndv : float ) Changes no_data_value of the DEM object. Example dem . change_ndv ( - 9999. ) print ( dem . no_data_value ) # -9999.0 Arguments ndv (float) : New no_data_value set_to_ndv DEM . set_to_ndv ( self , value : float ) Changes all occurances of value in the DEM data to no_data_value . Example dem.set_to_ndv(dem.dem[0][0]) print(dem.dem == dem.no_data_value) # True Arguments value (float) : raster value to replace set_verbosity DEM . set_verbosity ( self , verb_level : int , filename : str = None ) Set the verbosity level of printed output. NOTHING : Nothing (except warnings and related) INFO : Log output FULL : Log output and LaGriT output DEBUG : Log output, LaGriT output, and turns on debug mode Each of these verbosity levels are variables in tinerator.config . Example dem . set_verbosity ( tinerator . config . FULL ) Arguments verb_level (int) : verbosity level Optional Arguments filename (str): file to write log output to plot DEM . plot ( self , plot_out = None ) Draws the DEM and distance map. Optional Arguments plot_out (str): file path to save image Example dem = loadDEM ( \"example.asc\" ) dem . plot () ### fillDepressions `` ` python DEM . fillDepressions ( self , fill_depressions : bool = True , fill_flats : bool = True ) Fills flats and depressions on DEM. On meshes intended to be high- resolution, leaving flats and depressions untouched may cause solver issues. This method should be called before generating a triplane. Arguments fill_depressions (bool) : fill pits and depressions on DEM fill_flats (bool) : fill flats on DEM Example dem1 = loadDEM ( \"example.asc\" ) dem2 = loadDEM ( \"example.asc\" ) dem1 . fillDepressions () plt . imshow ( dem1 . dem - dem2 . dem ) plt . show () ### watershedDelineation `` ` python DEM . watershedDelineation ( self , threshold : float = None , plot : bool = False , spacing : float = None , method : str = 'D8' ) Performs watershed delineation on a DEM and returns a set of points corresponding to the feature. Available methods are: D8 D4 Rho8 Rho4 Dinf Quinn Holmgren Freeman Arguments threshold (float) : threshold for determining feature from noise plot (bool) : plot the watershed delineation and captured feature spacing (float) : the 'resolution' of the feature polygon method (str) : Flow calculation method Returns Polyline of feature as ordered (x,y) pairs generateBoundary DEM . generateBoundary ( self , distance : float ) Generates a set of spaced nodes corresponding to the boundary of the DEM, where the boundary is defined as the intersection of noDataValue and elevation data. Attributes distance (float) : Euclidean distance between adjacent boundary nodes Returns vertices of boundary buildUniformTriplane DEM . buildUniformTriplane ( self , min_edge : float , plot : bool = False , smooth_boundary : bool = False , flip : str = 'y' , apply_elevation : bool = True ) Generates a triplane with uniformly sized elements. Attributes min_edge (float) : triangle edge lengths Optional Arugments plot (bool): display the triangulation on completion flip (str): flips array of the elevation raster along a given axis (x,y,xy) buildRefinedTriplane DEM . buildRefinedTriplane ( self , min_edge : float , delta : float = 0.75 , outfile : str = None , slope : float = 2.0 , refine_dist : float = 0.5 , apply_elevation : bool = True , flip : str = 'y' , plot : bool = False , smooth_boundary : bool = False ) Generates a refined triangular mesh, with a minimum refinement length defined by h. Attributes min_edge (float) : triangle edge lengths Optional Arugments plot (bool): display the triangulation on completion flip (str): flips array of the elevation raster along a given axis (x,y,xy) layeredMesh DEM . layeredMesh ( self , layers , matids = None , xy_subset = None , outfile = None ) Builds a layered mesh from a triplane. Arguments layers (list ) : List of sequential layer thicknesses Optional Arguments matids (list<int): List of numbers to set as material ID for a list outfile (str): Filepath to save mesh to xy_subset (): Example layers = [ 1. , 1. , 3. , 10. , 2. ] matids = [ 1 , 1 , 2 , 1 , 3 ] dem . layeredMesh ( layers , matids = matids ) addAttribute DEM . addAttribute ( self , data , layers = None , attribute_name = None , outfile = None , dtype =< class ' float '>) Adds an attribute to the stacked mesh, over one or more layers. Default is all. Data must be an NxM matrix - it does not necessarily have to be the same size at the DEM, but is recommended as it will be streched to span the domain of it. attribute_name will be the element-based attribute the data is written into. The default is 'material ID', but can be changed to any [a-z][A-Z][0-9] string (outside of reserved LaGriT keywords). :param data: NxM matrix of data to be written as matrix :type data: np.ndarray :param layers: Layer IDs to write attributes to. Defaults to 'all'. :type layers: list :param attribute_name: Attribute name to store data in. Defaults to material ID :type attribute_name: str :param outfile: Filename to write mesh to :type outfile: str :param dtype: Data type of elements in data. Defaults to float :type dtype: type mapFunctionToAttribute DEM . mapFunctionToAttribute ( self , operator = '+' , layers = None , attribute_name = None , outfile = None , fn =< function DEM .< lambda > at 0x1a21c7fe18 > ) Maps a function and on operator onto mesh data. The function fn should take one parameter: the current layer number. The operator will perform on the data and function result. In other words, the new attribute data will be a result of: attribute_data(layer) = attribute_data [operation] fn(layer) For fn = lambda layer: layer*100 and operator '+', attribute_data(layer) = attribute_data + layer*100 meaning that if a selection of attribute data is [1,3,5,10,12...] then, with operator '+' and lambda layer: layer*100, layer 1: [101,103,105,110,112...] layer 2: [201,203,205,210,212...] layer 3: [301,103,305,310,312...] ... generateFacesets DEM . generateFacesets ( self , outfile , facesets = None , naive = False ) Generate boundary face sets according to normal vectors and layer ID. :param lg: running instance of PyLaGriT :type lg: pylagrit.PyLaGriT :param outfile: filepath to save Exodus facesets :type outfile: str :param facesets: generated facesets integer array with length equal to boundary :type facesets: np.ndarray :param naive: flag to generate Exodus mesh with 3 facesets: top, bottom, sides :type naive: bool calculateDistanceField DEM . calculateDistanceField ( self , accumulation_threshold : float = 75.0 , mask : bool = True , normalize : bool = True ) Calculates the distance field for a DEM. To adjust the visibility of features, you may have to tweak the accumulation threshold. :param accumulation_threshold: feature threshold :type accumulation_threshold: float :param mask: flag to mask distance map similar to DEM :type mask: bool :returns: generated distance field getBoundingBox DEM . getBoundingBox ( self , mpl_style : bool = True ) Returns the bounding box (or extent) of the DEM domain. By default, the format of the extent returned is: (x_min,x_max,y_min,y_max) By setting mpl_style=False , the format changes to: (x_min,y_min,x_max,y_max) Extent units are relative to the parent DEM coordinate system. Optional Arguments mpl_style (bool): Change the format of the returned extent Returns DEM domain bounding box","title":"Index"},{"location":"api/index.html#tinerator","text":"","title":"tinerator"},{"location":"api/index.html#loaddem","text":"loadDEM ( filepath : str , lagrit_exe : str = None ) Loads a DEM raster from a local filepath and returns a tinerator.DEM instance. Attributes filepath (str) : Filepath to DEM raster lagrit_exe (str,None) : Optional filepath to LaGriT binary. If PyLaGriT is configured correctly, this should be unnecessary.","title":"loadDEM"},{"location":"api/index.html#dem","text":"DEM ( self , filepath : str , lagrit_exe : str = None ) This is the 'main' class of TINerator, and stores all DEM and GIS data related to a particular project. Attributes filepath (str) : Filepath to DEM raster lagrit_exe (str,None) : Optional filepath to LaGriT binary. If PyLaGriT is configured correctly, this should be unnecessary.","title":"DEM"},{"location":"api/index.html#change_ndv","text":"DEM . change_ndv ( self , ndv : float ) Changes no_data_value of the DEM object. Example dem . change_ndv ( - 9999. ) print ( dem . no_data_value ) # -9999.0 Arguments ndv (float) : New no_data_value","title":"change_ndv"},{"location":"api/index.html#set_to_ndv","text":"DEM . set_to_ndv ( self , value : float ) Changes all occurances of value in the DEM data to no_data_value . Example dem.set_to_ndv(dem.dem[0][0]) print(dem.dem == dem.no_data_value) # True Arguments value (float) : raster value to replace","title":"set_to_ndv"},{"location":"api/index.html#set_verbosity","text":"DEM . set_verbosity ( self , verb_level : int , filename : str = None ) Set the verbosity level of printed output. NOTHING : Nothing (except warnings and related) INFO : Log output FULL : Log output and LaGriT output DEBUG : Log output, LaGriT output, and turns on debug mode Each of these verbosity levels are variables in tinerator.config . Example dem . set_verbosity ( tinerator . config . FULL ) Arguments verb_level (int) : verbosity level Optional Arguments filename (str): file to write log output to","title":"set_verbosity"},{"location":"api/index.html#plot","text":"DEM . plot ( self , plot_out = None ) Draws the DEM and distance map. Optional Arguments plot_out (str): file path to save image Example dem = loadDEM ( \"example.asc\" ) dem . plot () ### fillDepressions `` ` python DEM . fillDepressions ( self , fill_depressions : bool = True , fill_flats : bool = True ) Fills flats and depressions on DEM. On meshes intended to be high- resolution, leaving flats and depressions untouched may cause solver issues. This method should be called before generating a triplane. Arguments fill_depressions (bool) : fill pits and depressions on DEM fill_flats (bool) : fill flats on DEM Example dem1 = loadDEM ( \"example.asc\" ) dem2 = loadDEM ( \"example.asc\" ) dem1 . fillDepressions () plt . imshow ( dem1 . dem - dem2 . dem ) plt . show () ### watershedDelineation `` ` python DEM . watershedDelineation ( self , threshold : float = None , plot : bool = False , spacing : float = None , method : str = 'D8' ) Performs watershed delineation on a DEM and returns a set of points corresponding to the feature. Available methods are: D8 D4 Rho8 Rho4 Dinf Quinn Holmgren Freeman Arguments threshold (float) : threshold for determining feature from noise plot (bool) : plot the watershed delineation and captured feature spacing (float) : the 'resolution' of the feature polygon method (str) : Flow calculation method Returns Polyline of feature as ordered (x,y) pairs","title":"plot"},{"location":"api/index.html#generateboundary","text":"DEM . generateBoundary ( self , distance : float ) Generates a set of spaced nodes corresponding to the boundary of the DEM, where the boundary is defined as the intersection of noDataValue and elevation data. Attributes distance (float) : Euclidean distance between adjacent boundary nodes Returns vertices of boundary","title":"generateBoundary"},{"location":"api/index.html#builduniformtriplane","text":"DEM . buildUniformTriplane ( self , min_edge : float , plot : bool = False , smooth_boundary : bool = False , flip : str = 'y' , apply_elevation : bool = True ) Generates a triplane with uniformly sized elements. Attributes min_edge (float) : triangle edge lengths Optional Arugments plot (bool): display the triangulation on completion flip (str): flips array of the elevation raster along a given axis (x,y,xy)","title":"buildUniformTriplane"},{"location":"api/index.html#buildrefinedtriplane","text":"DEM . buildRefinedTriplane ( self , min_edge : float , delta : float = 0.75 , outfile : str = None , slope : float = 2.0 , refine_dist : float = 0.5 , apply_elevation : bool = True , flip : str = 'y' , plot : bool = False , smooth_boundary : bool = False ) Generates a refined triangular mesh, with a minimum refinement length defined by h. Attributes min_edge (float) : triangle edge lengths Optional Arugments plot (bool): display the triangulation on completion flip (str): flips array of the elevation raster along a given axis (x,y,xy)","title":"buildRefinedTriplane"},{"location":"api/index.html#layeredmesh","text":"DEM . layeredMesh ( self , layers , matids = None , xy_subset = None , outfile = None ) Builds a layered mesh from a triplane. Arguments layers (list ) : List of sequential layer thicknesses Optional Arguments matids (list<int): List of numbers to set as material ID for a list outfile (str): Filepath to save mesh to xy_subset (): Example layers = [ 1. , 1. , 3. , 10. , 2. ] matids = [ 1 , 1 , 2 , 1 , 3 ] dem . layeredMesh ( layers , matids = matids )","title":"layeredMesh"},{"location":"api/index.html#addattribute","text":"DEM . addAttribute ( self , data , layers = None , attribute_name = None , outfile = None , dtype =< class ' float '>) Adds an attribute to the stacked mesh, over one or more layers. Default is all. Data must be an NxM matrix - it does not necessarily have to be the same size at the DEM, but is recommended as it will be streched to span the domain of it. attribute_name will be the element-based attribute the data is written into. The default is 'material ID', but can be changed to any [a-z][A-Z][0-9] string (outside of reserved LaGriT keywords). :param data: NxM matrix of data to be written as matrix :type data: np.ndarray :param layers: Layer IDs to write attributes to. Defaults to 'all'. :type layers: list :param attribute_name: Attribute name to store data in. Defaults to material ID :type attribute_name: str :param outfile: Filename to write mesh to :type outfile: str :param dtype: Data type of elements in data. Defaults to float :type dtype: type","title":"addAttribute"},{"location":"api/index.html#mapfunctiontoattribute","text":"DEM . mapFunctionToAttribute ( self , operator = '+' , layers = None , attribute_name = None , outfile = None , fn =< function DEM .< lambda > at 0x1a21c7fe18 > ) Maps a function and on operator onto mesh data. The function fn should take one parameter: the current layer number. The operator will perform on the data and function result. In other words, the new attribute data will be a result of: attribute_data(layer) = attribute_data [operation] fn(layer) For fn = lambda layer: layer*100 and operator '+', attribute_data(layer) = attribute_data + layer*100 meaning that if a selection of attribute data is [1,3,5,10,12...] then, with operator '+' and lambda layer: layer*100, layer 1: [101,103,105,110,112...] layer 2: [201,203,205,210,212...] layer 3: [301,103,305,310,312...] ...","title":"mapFunctionToAttribute"},{"location":"api/index.html#generatefacesets","text":"DEM . generateFacesets ( self , outfile , facesets = None , naive = False ) Generate boundary face sets according to normal vectors and layer ID. :param lg: running instance of PyLaGriT :type lg: pylagrit.PyLaGriT :param outfile: filepath to save Exodus facesets :type outfile: str :param facesets: generated facesets integer array with length equal to boundary :type facesets: np.ndarray :param naive: flag to generate Exodus mesh with 3 facesets: top, bottom, sides :type naive: bool","title":"generateFacesets"},{"location":"api/index.html#calculatedistancefield","text":"DEM . calculateDistanceField ( self , accumulation_threshold : float = 75.0 , mask : bool = True , normalize : bool = True ) Calculates the distance field for a DEM. To adjust the visibility of features, you may have to tweak the accumulation threshold. :param accumulation_threshold: feature threshold :type accumulation_threshold: float :param mask: flag to mask distance map similar to DEM :type mask: bool :returns: generated distance field","title":"calculateDistanceField"},{"location":"api/index.html#getboundingbox","text":"DEM . getBoundingBox ( self , mpl_style : bool = True ) Returns the bounding box (or extent) of the DEM domain. By default, the format of the extent returned is: (x_min,x_max,y_min,y_max) By setting mpl_style=False , the format changes to: (x_min,y_min,x_max,y_max) Extent units are relative to the parent DEM coordinate system. Optional Arguments mpl_style (bool): Change the format of the returned extent Returns DEM domain bounding box","title":"getBoundingBox"},{"location":"api/developernotes.html","text":"For Developers Project To-Do's To see current bug fixes and issues under development, visit the Issues page (label:tinerator) . To request a feature or to add a bug report, submit a ticket on the LaGriT Issues page with label: tinerator. Contributing Best practices on contributing to this project, including formatting API docstrings, can be found in the Contributing page. Code Formatting Use the Black code formatter to ensure that code fits within a standardized style. Documentation Compilation Documentation is found in the tinerator/docs folder and is written in Markdown. The static site is generated by MkDocs using the Materials theme . Required MkDocs Extensions Package Command MathJax pip install pymdown-extensions Codehilite pip install pygments Materials theme pip install mkdocs-material API Generation To generate API documents, you will need pydoc-markdown . This can be installed via: pip install pydoc-markdown Then, run: pydocmd simple tinerator+ > docs.md Viewing the Site After all requirements are resolved, run mkdocs serve to start the local server. Navigate your web browser to the local server address (i.e., http://127.0.0.1:8000 ) to view. MkDocs will automatically reload the static site upon any detected file change within the docs/ folder. HTML files can be generated by using mkdocs build . Note This manual process will eventually be phased out in support for TravisCI-based continuous deployment. Pull requests on this topic are welcome.","title":"For Developers"},{"location":"api/developernotes.html#for-developers","text":"","title":"For Developers"},{"location":"api/developernotes.html#project-to-dos","text":"To see current bug fixes and issues under development, visit the Issues page (label:tinerator) . To request a feature or to add a bug report, submit a ticket on the LaGriT Issues page with label: tinerator.","title":"Project To-Do's"},{"location":"api/developernotes.html#contributing","text":"Best practices on contributing to this project, including formatting API docstrings, can be found in the Contributing page.","title":"Contributing"},{"location":"api/developernotes.html#code-formatting","text":"Use the Black code formatter to ensure that code fits within a standardized style.","title":"Code Formatting"},{"location":"api/developernotes.html#documentation-compilation","text":"Documentation is found in the tinerator/docs folder and is written in Markdown. The static site is generated by MkDocs using the Materials theme .","title":"Documentation Compilation"},{"location":"api/developernotes.html#required-mkdocs-extensions","text":"Package Command MathJax pip install pymdown-extensions Codehilite pip install pygments Materials theme pip install mkdocs-material","title":"Required MkDocs Extensions"},{"location":"api/developernotes.html#api-generation","text":"To generate API documents, you will need pydoc-markdown . This can be installed via: pip install pydoc-markdown Then, run: pydocmd simple tinerator+ > docs.md","title":"API Generation"},{"location":"api/developernotes.html#viewing-the-site","text":"After all requirements are resolved, run mkdocs serve to start the local server. Navigate your web browser to the local server address (i.e., http://127.0.0.1:8000 ) to view. MkDocs will automatically reload the static site upon any detected file change within the docs/ folder. HTML files can be generated by using mkdocs build . Note This manual process will eventually be phased out in support for TravisCI-based continuous deployment. Pull requests on this topic are welcome.","title":"Viewing the Site"},{"location":"tutorials/index.html","text":"Tutorial Importing DEMs and Shapefiles Overview on loading or downloading DEMs, basic GIS plotting and manipulation. Preparing the DEM Defining a mesh boundary and finding a stream network ('feature') through watershed delineation. Generating a Mesh Turning the DEM into a surface or volume mesh; uniform element density, or mesh refinement around a feature. Adding an Attribute Adding and manipulating cell and node attributes. Defining Facesets Defining subdomains of the mesh surfaces for setting solver boundary conditions.","title":"Index"},{"location":"tutorials/index.html#tutorial","text":"","title":"Tutorial"},{"location":"tutorials/index.html#importing-dems-and-shapefiles","text":"Overview on loading or downloading DEMs, basic GIS plotting and manipulation.","title":"Importing DEMs and Shapefiles"},{"location":"tutorials/index.html#preparing-the-dem","text":"Defining a mesh boundary and finding a stream network ('feature') through watershed delineation.","title":"Preparing the DEM"},{"location":"tutorials/index.html#generating-a-mesh","text":"Turning the DEM into a surface or volume mesh; uniform element density, or mesh refinement around a feature.","title":"Generating a Mesh"},{"location":"tutorials/index.html#adding-an-attribute","text":"Adding and manipulating cell and node attributes.","title":"Adding an Attribute"},{"location":"tutorials/index.html#defining-facesets","text":"Defining subdomains of the mesh surfaces for setting solver boundary conditions.","title":"Defining Facesets"},{"location":"tutorials/attributes.html","text":"Adding an Attribute Cell and node based attributes can be added to a stacked mesh - the attributes can be added either globally, across all layers, or local to one or more layers. Left: Soil map as read from an ASC file. Right: Soil map selectively applied to TIN layers. Reading and applying an attribute Basic syntax To add an attribute to a layered TIN, use the command: tinerator . DEM . addAttribute ( data , layers = [], dtype = int ) where layers is a list containing all layers to apply the attribute to, and dtype is the desired attribute type ( int or float ). By default, the material will be applied to the mesh's material ID (or, 'cell color'). This can be changed with the name parameter. As an example, consider a stacked mesh with three layers and an arbitrary floating point attribute. To apply that attribute only to the second layer: my_dem . addAttribute ( data , layers = [ 2 ], dtype = float ) By default, layers = None . This applies the attribute raster to every layer of the mesh. Note Any number of attribute rasters can be applied to a mesh, as long as each is given a unique name. Attribute Format Attributes must fundamentally be an N\\times M N\\times M Numpy matrix. The dimensions of the matrix do not necessarily have to be the same as those of the DEM. The data argument of addAttribute must be of type np.ndarray . To import or convert from popular file formats, a table of functions is given below. Click the function name to be redirected to its documentation. Data type Import function GIS rasters ( .asc , .tif , ...) gdal.Open(file) Plain-text matrix ( .txt , .dat , ...) numpy.loadtxt(file) Python list np.array(list) HDF5 ( .h5 ) h5py.File(file,'r') Note that when attributes are applied in TINerator, their domain spans that of the parent DEM. In other words, it is assumed that the data matrix has the same lower-left and upper-right corners as the DEM it is being applied to. Considering Data Types As mesh nodes will not necessarily align within cell centers of attribute raster, interpolation on that raster is performed. Based on the argument dtype , interpolation onto the mesh nodes will either be continuous ( float ) or nearest-neighbor ( int ). This is critical for properties such as soil ID, which only hold value as defined integers. Applying a function Assume that an attribute has been applied across all layers of the mesh. In some situations, it may be beneficial to change the attribute values based on the layer ID. The below method maps a user-defined function and operator onto mesh data: tinerator . DEM . mapFunctionToAttribute ( self , operator = '+' , layers = None , attribute_name = None , outfile = None , fn = lambda layer : layer * 100 ) In other words, the new attribute data will be a result of: A_{i,j}(layer) = A_{i,j} \\: [operation] \\: f(layer) \\: \\forall \\: i,j A_{i,j}(layer) = A_{i,j} \\: [operation] \\: f(layer) \\: \\forall \\: i,j where A_{i,j} A_{i,j} is the attribute raster data at index i,j i,j . Example Assume that we have soil types with unique values [1,3,5,10,12...] , applied to all layers of some mesh. To better define, say, porosity as a function of layer in our simulation, we would like to prefix each value with the layer ID. In other words, changing layer 1: [1,3,5,10,12...] layer 2: [1,3,5,10,12...] layer 3: [1,3,5,10,12...] ... to layer 1: [101,103,105,110,112...] layer 2: [201,203,205,210,212...] layer 3: [301,103,305,310,312...] ... This can be accomplished by using the following function: A_{i,j}(layer) = A_{i,j} + 100 \\cdot layer \\: \\forall \\: i,j A_{i,j}(layer) = A_{i,j} + 100 \\cdot layer \\: \\forall \\: i,j That is, adding 100 \\cdot layer_{ID} 100 \\cdot layer_{ID} to every attribute data point. Consequently, we want the operator to be + + and f(layer) = 100 \\cdot layer f(layer) = 100 \\cdot layer , or, my_dem . mapFunctionToAttribute ( attribute_name = 'exampleAttribute' , operator = '+' , fn = lambda layer : layer * 100 )","title":"Adding an Attribute"},{"location":"tutorials/attributes.html#adding-an-attribute","text":"Cell and node based attributes can be added to a stacked mesh - the attributes can be added either globally, across all layers, or local to one or more layers. Left: Soil map as read from an ASC file. Right: Soil map selectively applied to TIN layers.","title":"Adding an Attribute"},{"location":"tutorials/attributes.html#reading-and-applying-an-attribute","text":"","title":"Reading and applying an attribute"},{"location":"tutorials/attributes.html#basic-syntax","text":"To add an attribute to a layered TIN, use the command: tinerator . DEM . addAttribute ( data , layers = [], dtype = int ) where layers is a list containing all layers to apply the attribute to, and dtype is the desired attribute type ( int or float ). By default, the material will be applied to the mesh's material ID (or, 'cell color'). This can be changed with the name parameter. As an example, consider a stacked mesh with three layers and an arbitrary floating point attribute. To apply that attribute only to the second layer: my_dem . addAttribute ( data , layers = [ 2 ], dtype = float ) By default, layers = None . This applies the attribute raster to every layer of the mesh. Note Any number of attribute rasters can be applied to a mesh, as long as each is given a unique name.","title":"Basic syntax"},{"location":"tutorials/attributes.html#attribute-format","text":"Attributes must fundamentally be an N\\times M N\\times M Numpy matrix. The dimensions of the matrix do not necessarily have to be the same as those of the DEM. The data argument of addAttribute must be of type np.ndarray . To import or convert from popular file formats, a table of functions is given below. Click the function name to be redirected to its documentation. Data type Import function GIS rasters ( .asc , .tif , ...) gdal.Open(file) Plain-text matrix ( .txt , .dat , ...) numpy.loadtxt(file) Python list np.array(list) HDF5 ( .h5 ) h5py.File(file,'r') Note that when attributes are applied in TINerator, their domain spans that of the parent DEM. In other words, it is assumed that the data matrix has the same lower-left and upper-right corners as the DEM it is being applied to.","title":"Attribute Format"},{"location":"tutorials/attributes.html#considering-data-types","text":"As mesh nodes will not necessarily align within cell centers of attribute raster, interpolation on that raster is performed. Based on the argument dtype , interpolation onto the mesh nodes will either be continuous ( float ) or nearest-neighbor ( int ). This is critical for properties such as soil ID, which only hold value as defined integers.","title":"Considering Data Types"},{"location":"tutorials/attributes.html#applying-a-function","text":"Assume that an attribute has been applied across all layers of the mesh. In some situations, it may be beneficial to change the attribute values based on the layer ID. The below method maps a user-defined function and operator onto mesh data: tinerator . DEM . mapFunctionToAttribute ( self , operator = '+' , layers = None , attribute_name = None , outfile = None , fn = lambda layer : layer * 100 ) In other words, the new attribute data will be a result of: A_{i,j}(layer) = A_{i,j} \\: [operation] \\: f(layer) \\: \\forall \\: i,j A_{i,j}(layer) = A_{i,j} \\: [operation] \\: f(layer) \\: \\forall \\: i,j where A_{i,j} A_{i,j} is the attribute raster data at index i,j i,j .","title":"Applying a function"},{"location":"tutorials/attributes.html#example","text":"Assume that we have soil types with unique values [1,3,5,10,12...] , applied to all layers of some mesh. To better define, say, porosity as a function of layer in our simulation, we would like to prefix each value with the layer ID. In other words, changing layer 1: [1,3,5,10,12...] layer 2: [1,3,5,10,12...] layer 3: [1,3,5,10,12...] ... to layer 1: [101,103,105,110,112...] layer 2: [201,203,205,210,212...] layer 3: [301,103,305,310,312...] ... This can be accomplished by using the following function: A_{i,j}(layer) = A_{i,j} + 100 \\cdot layer \\: \\forall \\: i,j A_{i,j}(layer) = A_{i,j} + 100 \\cdot layer \\: \\forall \\: i,j That is, adding 100 \\cdot layer_{ID} 100 \\cdot layer_{ID} to every attribute data point. Consequently, we want the operator to be + + and f(layer) = 100 \\cdot layer f(layer) = 100 \\cdot layer , or, my_dem . mapFunctionToAttribute ( attribute_name = 'exampleAttribute' , operator = '+' , fn = lambda layer : layer * 100 )","title":"Example"},{"location":"tutorials/basics.html","text":"Importing DEMs and GIS data The DEM class structure After reading or downloading a DEM, an object of type tinerator.DEM is returned. This class contains all information related to tinning a particular GIS object: GIS data, such as the DEM matrix and shapefile polygons, meshing data, spatial data, and more. Further information on this class can be found by reading the API Documentation . The DEM - and associated metadata - is stored in the tinerator.DEM.dem attribute, which itself is a richdem.rdarray object: >>> print ( my_dem . dem . __dict__ ) { 'metadata' : { 'PROCESSING_HISTORY' : ' \\n 2019-01-23 18:53:20.598492 UTC | RichDEM (Python 0.3.4) (hash=\"ee05922\", hashdate=\"2018-07-13 13:01:09 -0700\") | LoadGDAL(filename=data/dem.asc, no_data=-9999.0)' }, 'no_data' : - 9999.0 , 'projection' : '' , 'geotransform' : ( 0.0 , 10.0 , 0.0 , 7510.0 , 0.0 , - 10.0 ) } Upon load, this metadata is parsed into specific tinerator.DEM variables. It is unlikely an end-user will need access to this RichDEM metadata. Reading DEMs Reading a DEM by file Reading a DEM via file is simply called by: my_dem = tinerator . loadDEM ( \"data/dem.asc\" ) The loading function uses GDAL as the I/O driver. Supported input filetypes can be found here . To verify import integrity, we can then plot the DEM and print metadata: my_dem . plot () print ( \"NODATAVALUE: {0} \\n Lower-left Corner: ({1},{2}) \\n Cell Size: {3}\" . format ( my_dem . no_data_value , my_dem . xll_corner , my_dem . yll_corner , my_dem . cell_size ) ) >>> NODATAVALUE: -9999.0 >>> Lower-left Corner: (0.0,0.0) >>> Cell Size: 10.0 Each of these metadata values are mutable and can be changed as circumstances dictate. Downloading from coordinates To download an SRTM 90m DEM by through a latitude / longitude bounding box, my_dem = tinerator . downloadDEM ( bounds = ( 12.35 , 41.8 , 12.65 , 42 ), outfile = 'Rome-90m-DEM.tif' ) where bounds is the bounding box values in geodetic coordinates (left, bottom, right, top), and outfile is an optional filepath to save the DEM. In this example, (12.35,41.8,12.65,42) represents a subsection of Rome: Downloading by Shapefile To download an SRTM 90m DEM through a Shapefile ( .shp ), my_dem = tinerator . downloadDEM ( shapefile = \"shapefile.shp\" , crop = True ) The argument crop replaces all areas of the DEM not covered by the shapefile with a NoDataValue. Setting crop = False will only return a DEM bound by the spatial domain of the shapefile. With crop = True : With crop = False : Applying a Shapefile Coming soon","title":"Importing DEMs"},{"location":"tutorials/basics.html#importing-dems-and-gis-data","text":"","title":"Importing DEMs and GIS data"},{"location":"tutorials/basics.html#the-dem-class-structure","text":"After reading or downloading a DEM, an object of type tinerator.DEM is returned. This class contains all information related to tinning a particular GIS object: GIS data, such as the DEM matrix and shapefile polygons, meshing data, spatial data, and more. Further information on this class can be found by reading the API Documentation . The DEM - and associated metadata - is stored in the tinerator.DEM.dem attribute, which itself is a richdem.rdarray object: >>> print ( my_dem . dem . __dict__ ) { 'metadata' : { 'PROCESSING_HISTORY' : ' \\n 2019-01-23 18:53:20.598492 UTC | RichDEM (Python 0.3.4) (hash=\"ee05922\", hashdate=\"2018-07-13 13:01:09 -0700\") | LoadGDAL(filename=data/dem.asc, no_data=-9999.0)' }, 'no_data' : - 9999.0 , 'projection' : '' , 'geotransform' : ( 0.0 , 10.0 , 0.0 , 7510.0 , 0.0 , - 10.0 ) } Upon load, this metadata is parsed into specific tinerator.DEM variables. It is unlikely an end-user will need access to this RichDEM metadata.","title":"The DEM class structure"},{"location":"tutorials/basics.html#reading-dems","text":"","title":"Reading DEMs"},{"location":"tutorials/basics.html#reading-a-dem-by-file","text":"Reading a DEM via file is simply called by: my_dem = tinerator . loadDEM ( \"data/dem.asc\" ) The loading function uses GDAL as the I/O driver. Supported input filetypes can be found here . To verify import integrity, we can then plot the DEM and print metadata: my_dem . plot () print ( \"NODATAVALUE: {0} \\n Lower-left Corner: ({1},{2}) \\n Cell Size: {3}\" . format ( my_dem . no_data_value , my_dem . xll_corner , my_dem . yll_corner , my_dem . cell_size ) ) >>> NODATAVALUE: -9999.0 >>> Lower-left Corner: (0.0,0.0) >>> Cell Size: 10.0 Each of these metadata values are mutable and can be changed as circumstances dictate.","title":"Reading a DEM by file"},{"location":"tutorials/basics.html#downloading-from-coordinates","text":"To download an SRTM 90m DEM by through a latitude / longitude bounding box, my_dem = tinerator . downloadDEM ( bounds = ( 12.35 , 41.8 , 12.65 , 42 ), outfile = 'Rome-90m-DEM.tif' ) where bounds is the bounding box values in geodetic coordinates (left, bottom, right, top), and outfile is an optional filepath to save the DEM. In this example, (12.35,41.8,12.65,42) represents a subsection of Rome:","title":"Downloading from coordinates"},{"location":"tutorials/basics.html#downloading-by-shapefile","text":"To download an SRTM 90m DEM through a Shapefile ( .shp ), my_dem = tinerator . downloadDEM ( shapefile = \"shapefile.shp\" , crop = True ) The argument crop replaces all areas of the DEM not covered by the shapefile with a NoDataValue. Setting crop = False will only return a DEM bound by the spatial domain of the shapefile. With crop = True : With crop = False :","title":"Downloading by Shapefile"},{"location":"tutorials/basics.html#applying-a-shapefile","text":"Coming soon","title":"Applying a Shapefile"},{"location":"tutorials/facesets.html","text":"Facesets Facesets are arbitrarily defined sections of the mesh's surface, which can be used in simulators such as ATS or Amanzi to define boundary conditions. A mesh using facesets is exported in the Exodus ( PDF ) format. Naive Facesets 'Naive' facesets are a collection of only three facesets: top, bottom, and sides. They can be generated with: my_dem . generateFacesets ( output_filepath , naive = True ) Complex Facesets In the above image, six distinct facesets are shown: Top layer Bottom layer Side (East) Side (West) Side (South) Outlet Note that the outlet faceset is localized entirely to the top layer. Faceset definitions such as these are unique to simulation parameters and goals. Consequently, they must be defined manually using one of two methods: Side selection via GUI fs_sides = selectFacesetsFromBoundary ( dem ) Upon running the above function, a Matplotlib-powered GUI will appear and Python will suspend further script execution until the window is closed. To use this tool, simply click a boundary node defining the start of a sideset. Then, in a clockwise manner, click the boundary node defining the end of a sideset. Nodes contained within that sideset will disappear from the boundary as they are no longer selectable. This process may be performed an arbitrary amount of times - note that the nodes 'left over' when the GUI window is closed will be defined as a sideset. When the window is closed, the function will return an array with sideset definitions. You can also run this function again to define top-layer sidesets - for, as an example, defining an inlet or outlet. fs_sides = selectFacesetsFromBoundary ( dem ) # Capture general sidesets fs_outlet = selectFacesetsFromBoundary ( dem ) # Capture the outlet sideset (top layer only!) my_dem . generateFacesets ( 'facesets_example.exo' , facesets = { 'all' : fs_sides , 'top' : fs_outlet }) Side selection via Coordinates If already you know the coordinates of the sidesets you wish to define, you can create an array defining starting/ending boundary nodes (in clockwise order ). Note that the coordinate space must be the same as the DEM. As an example, consider the following: scoords = { 'all' : np . array ([[ 3352.82 , 7284.46 ], [ 7936.85 , 4870.53 ], [ 1798.4 , 256.502 ], [ 1182.73 , 1030.19 ]]), 'top' : np . array ([[ 780.41 , 304.79 ], [ 567.05 , 524.24 ]]) } fs = getFacesetsFromCoordinates ( scoords , my_dem . boundary ) my_dem . generateFacesets ( 'facesets_example.exo' , facesets = fs ) The above code generates the exact same sidesets as in the GUI example. Top surface selection Feature under development","title":"Defining FaceSets"},{"location":"tutorials/facesets.html#facesets","text":"Facesets are arbitrarily defined sections of the mesh's surface, which can be used in simulators such as ATS or Amanzi to define boundary conditions. A mesh using facesets is exported in the Exodus ( PDF ) format.","title":"Facesets"},{"location":"tutorials/facesets.html#naive-facesets","text":"'Naive' facesets are a collection of only three facesets: top, bottom, and sides. They can be generated with: my_dem . generateFacesets ( output_filepath , naive = True )","title":"Naive Facesets"},{"location":"tutorials/facesets.html#complex-facesets","text":"In the above image, six distinct facesets are shown: Top layer Bottom layer Side (East) Side (West) Side (South) Outlet Note that the outlet faceset is localized entirely to the top layer. Faceset definitions such as these are unique to simulation parameters and goals. Consequently, they must be defined manually using one of two methods:","title":"Complex Facesets"},{"location":"tutorials/facesets.html#side-selection-via-gui","text":"fs_sides = selectFacesetsFromBoundary ( dem ) Upon running the above function, a Matplotlib-powered GUI will appear and Python will suspend further script execution until the window is closed. To use this tool, simply click a boundary node defining the start of a sideset. Then, in a clockwise manner, click the boundary node defining the end of a sideset. Nodes contained within that sideset will disappear from the boundary as they are no longer selectable. This process may be performed an arbitrary amount of times - note that the nodes 'left over' when the GUI window is closed will be defined as a sideset. When the window is closed, the function will return an array with sideset definitions. You can also run this function again to define top-layer sidesets - for, as an example, defining an inlet or outlet. fs_sides = selectFacesetsFromBoundary ( dem ) # Capture general sidesets fs_outlet = selectFacesetsFromBoundary ( dem ) # Capture the outlet sideset (top layer only!) my_dem . generateFacesets ( 'facesets_example.exo' , facesets = { 'all' : fs_sides , 'top' : fs_outlet })","title":"Side selection via GUI"},{"location":"tutorials/facesets.html#side-selection-via-coordinates","text":"If already you know the coordinates of the sidesets you wish to define, you can create an array defining starting/ending boundary nodes (in clockwise order ). Note that the coordinate space must be the same as the DEM. As an example, consider the following: scoords = { 'all' : np . array ([[ 3352.82 , 7284.46 ], [ 7936.85 , 4870.53 ], [ 1798.4 , 256.502 ], [ 1182.73 , 1030.19 ]]), 'top' : np . array ([[ 780.41 , 304.79 ], [ 567.05 , 524.24 ]]) } fs = getFacesetsFromCoordinates ( scoords , my_dem . boundary ) my_dem . generateFacesets ( 'facesets_example.exo' , facesets = fs ) The above code generates the exact same sidesets as in the GUI example.","title":"Side selection via Coordinates"},{"location":"tutorials/facesets.html#top-surface-selection","text":"Feature under development","title":"Top surface selection"},{"location":"tutorials/meshing.html","text":"Mesh Generation At this point, the DEM should be sufficiently post-processed, and we can begin the process of constructing a TIN. TIN generation is done in several discrete steps: Triplane (surface) generation Applying elevation to surface Extruding into defined layers Applying materials to layers Steps 1+2 and steps 3+4 are controlled with the following methods, respectively: tinerator . DEM . generateStackedTIN ( ** kwargs ) # Steps 1 & 2 tinerator . DEM . layeredMesh ( ** kwargs ) # Steps 3 & 4 Details on using these methods will be explained in the subsections below; for more information, read the method documentation . Building a Surface Mesh By default, TINerator will automatically determine whether to contruct a surface with refined or uniform triangles. If watershed delineation has not been performed, or the class variable tinerator.DEM.feature = None , then TINerator will generate a uniform surface. Otherwise, it will be refined. The generated surface mesh will maintain the same spatial domain as the parent DEM. This may cause overflow errors if the DEM domain is close to or exceeds the limit of a double-precision float. Uniform Once the boundary is generated, calculating a triplane is as simple as: my_dem . generateStackedTIN () The minimum edge length of the surface triangles will be equivalent to the spacing between adjacent boundary nodes, as defined in tinerator.DEM.generateBoundary() . To define a different edge length, use the method parameter min_edge : float , where the units of min_edge are the same units as the parent DEM. By default, DEM elevation data will be continuously interpolated onto the Z-values of the surface triangles. A completely flat mesh can be constructed instead with the method argument apply_elevation = False . Refined For generating a refined surface, call the method: my_dem . generateStackedTIN ( min_edge ) where min_edge will be the shortest edge generated in the refining process. This method works by (i) coarsely triangulating the interior of the boundary, and (ii) adaptively refining triangles according to a gradient field. The gradient field is a raster with values that scale relative to the Euclidean distance from the feature. Triangle edge length scales linearly from min_edge , where the gradient field is 0 (at the feature), towards max_edge , where the gradient field is 1 (at the edge of the DEM domain), according to this equation: e(i,j) = e_{min} + \\left( e_{max} - e_{min} \\right) \\cdot \\nabla D(i,j) e(i,j) = e_{min} + \\left( e_{max} - e_{min} \\right) \\cdot \\nabla D(i,j) As stated above, DEM elevation data will be interpolated onto the Z-coordinate of the surface nodes unless explicitly defined otherwise. Mesh Quality Triangulation is done with a Delaunay triangulation algorithm, and the mesh is iteratively smoothed with Laplacian smoothing . The number of smoothing / reconnection iterations can be controlled with the keyword iterations : int . Mesh quality can be found through the method: tinerator . DEM . quality ( 'surface' ) This returns a dictionary containing aspect ratio statistics ( \\theta_{max} / \\theta_{min} \\theta_{max} / \\theta_{min} ), edge length ratio statistics ( e_{max} / e_{min} e_{max} / e_{min} ), and count of malformed elements (triangles with very large angles, very small angles, or very small areas). Stacking the Mesh Mesh extrusion is the process of extruding a triangular surface mesh into a volumetric prism mesh. This method is called using tinerator . DEM . layeredMesh ( ** kwargs ) For more information, see the documentation . As an example, after generating a triangular surface mesh, it can be layered by: layers = [ 0.1 , 0.3 , 0.6 , 8. , 21. ] # Define layer thickness matids = [ 1 , 2 , 3 , 4 , 5 ] # Define material ID my_dem . layeredMesh ( layers , matids = matids ) where layers is a list of length N , containing the sequential depths of layers to extrude, and matids is a list of length N containing the sequential integer IDs for each layer. For example, layer 1 will have a depth of 0.1 meters and a material ID of 1, layer 2 will have a depth of 0.3 and a material ID of 2, and so on. Note The length of list layers must equal the length of list matids Layers Depending on your particular use case, you may want as few as one layer, or many more. Layers may be of any arbitrary thickness, with units the same as the DEM parent. Note that the number of elements in the volumetric mesh, N_{volume} N_{volume} , is directly proportional to the number of layers n_{layers} n_{layers} : N_{volume} = N_{surface} \\cdot n_{layers} N_{volume} = N_{surface} \\cdot n_{layers} Five-layer prism mesh. Layer depths have been strongly exaggerated for effect. Materials Each layer can optionally have its own material ID - this provides an easy way to identify which layer an element is in, or to find elements within a defined layer. Note that material ID is not necessarily an attribute - it is a non-zero integer value mapped to an element. Cell and node based attributes are applied using a different process - read more here . An exaggerated view of layers colored by material ID. Note that some values are unique to its layer, while other layers share an ID.","title":"Generating a Mesh"},{"location":"tutorials/meshing.html#mesh-generation","text":"At this point, the DEM should be sufficiently post-processed, and we can begin the process of constructing a TIN. TIN generation is done in several discrete steps: Triplane (surface) generation Applying elevation to surface Extruding into defined layers Applying materials to layers Steps 1+2 and steps 3+4 are controlled with the following methods, respectively: tinerator . DEM . generateStackedTIN ( ** kwargs ) # Steps 1 & 2 tinerator . DEM . layeredMesh ( ** kwargs ) # Steps 3 & 4 Details on using these methods will be explained in the subsections below; for more information, read the method documentation .","title":"Mesh Generation"},{"location":"tutorials/meshing.html#building-a-surface-mesh","text":"By default, TINerator will automatically determine whether to contruct a surface with refined or uniform triangles. If watershed delineation has not been performed, or the class variable tinerator.DEM.feature = None , then TINerator will generate a uniform surface. Otherwise, it will be refined. The generated surface mesh will maintain the same spatial domain as the parent DEM. This may cause overflow errors if the DEM domain is close to or exceeds the limit of a double-precision float.","title":"Building a Surface Mesh"},{"location":"tutorials/meshing.html#uniform","text":"Once the boundary is generated, calculating a triplane is as simple as: my_dem . generateStackedTIN () The minimum edge length of the surface triangles will be equivalent to the spacing between adjacent boundary nodes, as defined in tinerator.DEM.generateBoundary() . To define a different edge length, use the method parameter min_edge : float , where the units of min_edge are the same units as the parent DEM. By default, DEM elevation data will be continuously interpolated onto the Z-values of the surface triangles. A completely flat mesh can be constructed instead with the method argument apply_elevation = False .","title":"Uniform"},{"location":"tutorials/meshing.html#refined","text":"For generating a refined surface, call the method: my_dem . generateStackedTIN ( min_edge ) where min_edge will be the shortest edge generated in the refining process. This method works by (i) coarsely triangulating the interior of the boundary, and (ii) adaptively refining triangles according to a gradient field. The gradient field is a raster with values that scale relative to the Euclidean distance from the feature. Triangle edge length scales linearly from min_edge , where the gradient field is 0 (at the feature), towards max_edge , where the gradient field is 1 (at the edge of the DEM domain), according to this equation: e(i,j) = e_{min} + \\left( e_{max} - e_{min} \\right) \\cdot \\nabla D(i,j) e(i,j) = e_{min} + \\left( e_{max} - e_{min} \\right) \\cdot \\nabla D(i,j) As stated above, DEM elevation data will be interpolated onto the Z-coordinate of the surface nodes unless explicitly defined otherwise.","title":"Refined"},{"location":"tutorials/meshing.html#mesh-quality","text":"Triangulation is done with a Delaunay triangulation algorithm, and the mesh is iteratively smoothed with Laplacian smoothing . The number of smoothing / reconnection iterations can be controlled with the keyword iterations : int . Mesh quality can be found through the method: tinerator . DEM . quality ( 'surface' ) This returns a dictionary containing aspect ratio statistics ( \\theta_{max} / \\theta_{min} \\theta_{max} / \\theta_{min} ), edge length ratio statistics ( e_{max} / e_{min} e_{max} / e_{min} ), and count of malformed elements (triangles with very large angles, very small angles, or very small areas).","title":"Mesh Quality"},{"location":"tutorials/meshing.html#stacking-the-mesh","text":"Mesh extrusion is the process of extruding a triangular surface mesh into a volumetric prism mesh. This method is called using tinerator . DEM . layeredMesh ( ** kwargs ) For more information, see the documentation . As an example, after generating a triangular surface mesh, it can be layered by: layers = [ 0.1 , 0.3 , 0.6 , 8. , 21. ] # Define layer thickness matids = [ 1 , 2 , 3 , 4 , 5 ] # Define material ID my_dem . layeredMesh ( layers , matids = matids ) where layers is a list of length N , containing the sequential depths of layers to extrude, and matids is a list of length N containing the sequential integer IDs for each layer. For example, layer 1 will have a depth of 0.1 meters and a material ID of 1, layer 2 will have a depth of 0.3 and a material ID of 2, and so on. Note The length of list layers must equal the length of list matids","title":"Stacking the Mesh"},{"location":"tutorials/meshing.html#layers","text":"Depending on your particular use case, you may want as few as one layer, or many more. Layers may be of any arbitrary thickness, with units the same as the DEM parent. Note that the number of elements in the volumetric mesh, N_{volume} N_{volume} , is directly proportional to the number of layers n_{layers} n_{layers} : N_{volume} = N_{surface} \\cdot n_{layers} N_{volume} = N_{surface} \\cdot n_{layers} Five-layer prism mesh. Layer depths have been strongly exaggerated for effect.","title":"Layers"},{"location":"tutorials/meshing.html#materials","text":"Each layer can optionally have its own material ID - this provides an easy way to identify which layer an element is in, or to find elements within a defined layer. Note that material ID is not necessarily an attribute - it is a non-zero integer value mapped to an element. Cell and node based attributes are applied using a different process - read more here . An exaggerated view of layers colored by material ID. Note that some values are unique to its layer, while other layers share an ID.","title":"Materials"},{"location":"tutorials/watershed.html","text":"Preparing the DEM One of the most powerful features of TINerator is the ability to create meshes which are variably refined around some DEM feature, such as a river or stream network. To prepare the DEM for mesh generation, a feature needs to be (optionally) defined, and a boundary generated. Note that an option in TINerator exists to generate a mesh without feature refinement - see the mesh generation section for more information. Watershed Delineation Defining a river or stream network ('feature') in the DEM is done through the command: my_dem . watershedDelineation ( threshold = 4500. , plot = False , spacing = 30. ) Performing a watershed delineation is a multi-step process: Depressions ('pits') are filled Flats are resolved Flow accumulation is performed Resolving Depressions and Flats Source: Lindsay, John. (2015). Efficient hybrid breaching-filling sink removal methods for flow path enforcement in digital elevation models. Hydrological Processes. 30. 846\u2013857. doi: 10.1002/hyp.10648 . Flow accumulation algorithms are numerous , but they all tend to operate relative to elevation deltas between adjacent DEM cells. Consequently, flats and pits can disrupt accumulation algorithms, causing premature termination of the flow patterns. It is therefore, in general, best to preprocess a DEM to remove depressions and flats. Depressions and flats identified and removed on a standard DEM Flat and pit resolution is the default behavior of the watershedDelineation function. For more information on better controlling these steps, refer to the API Documentation . The DEM feature will be found in the class variable tinerator.DEM.feature , and is an N-by-2 np.ndarray defining a polyline. Flow accumulation A critical step in determining river networks is through flow accumulation algorithms. These algorithms generate a raster of accumulated flow by accumulating the weight of all cells that flow into adjacent cells with a negative elevation data ('downslope cells'). Source: ArcGis Pro, How Flow Accumulation works TINerator supports a number of popular flow accumulation algorithms: D8 D4 D-Infinity Rho8 Rho4 Quinn Freeman Holmgren By default, D8 is used. For more information on these different algorithms, visit the RichDEM Flow Metrics page . After flow accumulation is performed, the feature can be extracted by setting an accumulation threshold and defining all cells above that threshold to be a part of the feature. As an example, see the below figure: Left: Flow accumulation intensity. Right: Feature pulled by thresholding the flow accumulation matrix. On the left, the raster generated by the flow accumulation algorithm is displayed. Note that effectively all non-masked cells in the DEM have some non-zero amount of accumulation. By settings threshold = 0. , effectively the entire DEM would be 'captured' as a feature. Note that, if you only consider cells with more than 10^4 10^4 accumulations, a river network becomes visible. Consequently, the threshold should be set to reflect that. Here, threshold = 4.5E10 , and the feature derived from setting that threshold value is shown on the right of the figure. Note The optimal threshold value will change for each distinct DEM. Pay careful attention to set a value relative to your workflow goals. Boundary Generation Boundary generation is done using a Square Tracing Algorithm to quickly capture the perimeter of the DEM. The boundary is defined as the interface between cells with NoDataValue entries ( z_{i,j} = NDV z_{i,j} = NDV ) and cells with data ( z_{i,j} \\ne NDV z_{i,j} \\ne NDV ). For DEMs that do not have cells with NoDataValue elements ( z(i,j) \\cap NDV = \\emptyset z(i,j) \\cap NDV = \\emptyset ), a rectangular boundary spanning the domain of the DEM is generated instead. The boundary is generated with the method tinerator . DEM . generateBoundary ( delta : float ) where delta is the spacing between adjacent boundary nodes. The units of delta will be the same as the units of the parent DEM. Warning Boundary generation must be done before proceeding to mesh generation. As an example, my_dem . generateBoundary ( 100. ) my_dem . plotBoundary () will generate (and plot) a boundary with 100 meter spacing. The boundary array is mutable and can be found in the class variable tinerator.DEM.boundary .","title":"Preparing the DEM"},{"location":"tutorials/watershed.html#preparing-the-dem","text":"One of the most powerful features of TINerator is the ability to create meshes which are variably refined around some DEM feature, such as a river or stream network. To prepare the DEM for mesh generation, a feature needs to be (optionally) defined, and a boundary generated. Note that an option in TINerator exists to generate a mesh without feature refinement - see the mesh generation section for more information.","title":"Preparing the DEM"},{"location":"tutorials/watershed.html#watershed-delineation","text":"Defining a river or stream network ('feature') in the DEM is done through the command: my_dem . watershedDelineation ( threshold = 4500. , plot = False , spacing = 30. ) Performing a watershed delineation is a multi-step process: Depressions ('pits') are filled Flats are resolved Flow accumulation is performed","title":"Watershed Delineation"},{"location":"tutorials/watershed.html#resolving-depressions-and-flats","text":"Source: Lindsay, John. (2015). Efficient hybrid breaching-filling sink removal methods for flow path enforcement in digital elevation models. Hydrological Processes. 30. 846\u2013857. doi: 10.1002/hyp.10648 . Flow accumulation algorithms are numerous , but they all tend to operate relative to elevation deltas between adjacent DEM cells. Consequently, flats and pits can disrupt accumulation algorithms, causing premature termination of the flow patterns. It is therefore, in general, best to preprocess a DEM to remove depressions and flats. Depressions and flats identified and removed on a standard DEM Flat and pit resolution is the default behavior of the watershedDelineation function. For more information on better controlling these steps, refer to the API Documentation . The DEM feature will be found in the class variable tinerator.DEM.feature , and is an N-by-2 np.ndarray defining a polyline.","title":"Resolving Depressions and Flats"},{"location":"tutorials/watershed.html#flow-accumulation","text":"A critical step in determining river networks is through flow accumulation algorithms. These algorithms generate a raster of accumulated flow by accumulating the weight of all cells that flow into adjacent cells with a negative elevation data ('downslope cells'). Source: ArcGis Pro, How Flow Accumulation works TINerator supports a number of popular flow accumulation algorithms: D8 D4 D-Infinity Rho8 Rho4 Quinn Freeman Holmgren By default, D8 is used. For more information on these different algorithms, visit the RichDEM Flow Metrics page . After flow accumulation is performed, the feature can be extracted by setting an accumulation threshold and defining all cells above that threshold to be a part of the feature. As an example, see the below figure: Left: Flow accumulation intensity. Right: Feature pulled by thresholding the flow accumulation matrix. On the left, the raster generated by the flow accumulation algorithm is displayed. Note that effectively all non-masked cells in the DEM have some non-zero amount of accumulation. By settings threshold = 0. , effectively the entire DEM would be 'captured' as a feature. Note that, if you only consider cells with more than 10^4 10^4 accumulations, a river network becomes visible. Consequently, the threshold should be set to reflect that. Here, threshold = 4.5E10 , and the feature derived from setting that threshold value is shown on the right of the figure. Note The optimal threshold value will change for each distinct DEM. Pay careful attention to set a value relative to your workflow goals.","title":"Flow accumulation"},{"location":"tutorials/watershed.html#boundary-generation","text":"Boundary generation is done using a Square Tracing Algorithm to quickly capture the perimeter of the DEM. The boundary is defined as the interface between cells with NoDataValue entries ( z_{i,j} = NDV z_{i,j} = NDV ) and cells with data ( z_{i,j} \\ne NDV z_{i,j} \\ne NDV ). For DEMs that do not have cells with NoDataValue elements ( z(i,j) \\cap NDV = \\emptyset z(i,j) \\cap NDV = \\emptyset ), a rectangular boundary spanning the domain of the DEM is generated instead. The boundary is generated with the method tinerator . DEM . generateBoundary ( delta : float ) where delta is the spacing between adjacent boundary nodes. The units of delta will be the same as the units of the parent DEM. Warning Boundary generation must be done before proceeding to mesh generation. As an example, my_dem . generateBoundary ( 100. ) my_dem . plotBoundary () will generate (and plot) a boundary with 100 meter spacing. The boundary array is mutable and can be found in the class variable tinerator.DEM.boundary .","title":"Boundary Generation"}]}