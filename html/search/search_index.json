{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Introduction TINerator is a tool for the fast creation of extruded and refined meshes from DEM and GIS data, developed at Los Alamos National Laboratory to aid in hydrogeological simulations. TINerator allows a user to define a bounding box of latitude/longitude coordinates, a shapefile, or a local DEM, and generate a surface or volume mesh. The mesh will have the topology of the DEM, along with user-defined material IDs and depths for stacked layers. Further, TINerator performs watershed delination on the defined DEM and refines the mesh\u2019s elements around the feature to a user-defined length scale. TINerator comes with a host of 2D and 3D visualization functions, allowing the user to view the status of the mesh at every step in the workflow. In addition, there are geometrical tools for removing triangles outside of a polygon, generating quality analytics on the mesh, adding cell- and node-based attributes to a mesh, and much more.","title":"Introduction"},{"location":"index.html#introduction","text":"TINerator is a tool for the fast creation of extruded and refined meshes from DEM and GIS data, developed at Los Alamos National Laboratory to aid in hydrogeological simulations. TINerator allows a user to define a bounding box of latitude/longitude coordinates, a shapefile, or a local DEM, and generate a surface or volume mesh. The mesh will have the topology of the DEM, along with user-defined material IDs and depths for stacked layers. Further, TINerator performs watershed delination on the defined DEM and refines the mesh\u2019s elements around the feature to a user-defined length scale. TINerator comes with a host of 2D and 3D visualization functions, allowing the user to view the status of the mesh at every step in the workflow. In addition, there are geometrical tools for removing triangles outside of a polygon, generating quality analytics on the mesh, adding cell- and node-based attributes to a mesh, and much more.","title":"Introduction"},{"location":"about.html","text":"About TINerator Funding TINerator is a collaborative effort between Los Alamos National Laboratory and Lawrence Berkeley National Laboratory. Development of TINerator is sponsored in part by the NGEE Arctic and DOE IDEAS programs. Development Team Daniel Livingston (EES-16; Los Alamos National Laboratory) David Moulton (T-5; Los Alamos National Laboratory) Ilhan Ozgen (CESD; Lawrence Berkeley National Laboratory) Zexuan Xu (CESD; Lawrence Berkeley National Laboratory) Richard Middleton (EES-16; Los Alamos National Laboratory) Terry Miller (EES-16; Los Alamos National Laboratory) Carl Gable (EES-16; Los Alamos National Laboratory) Contact Contact livingston@lanl.gov with questions and issues. License TINerator is licensed under the BSD-3 license. Click here to visit the license page .","title":"About"},{"location":"about.html#about-tinerator","text":"","title":"About TINerator"},{"location":"about.html#funding","text":"TINerator is a collaborative effort between Los Alamos National Laboratory and Lawrence Berkeley National Laboratory. Development of TINerator is sponsored in part by the NGEE Arctic and DOE IDEAS programs.","title":"Funding"},{"location":"about.html#development-team","text":"Daniel Livingston (EES-16; Los Alamos National Laboratory) David Moulton (T-5; Los Alamos National Laboratory) Ilhan Ozgen (CESD; Lawrence Berkeley National Laboratory) Zexuan Xu (CESD; Lawrence Berkeley National Laboratory) Richard Middleton (EES-16; Los Alamos National Laboratory) Terry Miller (EES-16; Los Alamos National Laboratory) Carl Gable (EES-16; Los Alamos National Laboratory)","title":"Development Team"},{"location":"about.html#contact","text":"Contact livingston@lanl.gov with questions and issues.","title":"Contact"},{"location":"about.html#license","text":"TINerator is licensed under the BSD-3 license. Click here to visit the license page .","title":"License"},{"location":"contributing.html","text":"Contributing How to Contribute Contribution Requirements Pull requests for missing features, bug fixes, and documentation updates are more than welcome. To contribute, please submit a pull request at https://github.com/lanl/LaGriT To ensure the best chance of acceptance for your pull request, please ensure that: All tests pass Your code is well documented and commented If adding new functionality, that unit tests have been included in the PR That the purpose and scope of your contributions are well explained in the PR Need an Issue? Visit the Issues page of LaGriT and search for tag 'Good First Issue'. These are great issues for someone unfamiliar with the codebase to work on. Function Docstrings API documentation is generated using the pydoc-markdown package. Proper formatting is explained in the Syntax section of their documentation. As an example of proper formatting, def some_function ( self , required_param : str , opt_1 : str = None , opt_2 : int = 34 ): ''' Some function documentation. # Arguments required_param (str): Some description. # Optional Arguments opt_1 (str,None): Some description. # Raises ValueError: If *opt_1* does not end with `.md`. # Returns The object that is returned. ''' Contributor License Agreement (CLA) If you are an external (non-LANL or LBNL) contributor, then in order to accept your pull request, we need you to submit a CLA. This license is for your protection as a Contributor as well as the protection of LANL and LaGriT users; it does not change your rights to use your own Contributions for any other purpose. Sign the CLA here: https://www.clahub.com/agreements/lanl/LaGriT License By contributing to TINerator, you agree that your contributions will be licensed under the BSD-3 license.","title":"Contributing"},{"location":"contributing.html#contributing","text":"","title":"Contributing"},{"location":"contributing.html#how-to-contribute","text":"","title":"How to Contribute"},{"location":"contributing.html#contribution-requirements","text":"Pull requests for missing features, bug fixes, and documentation updates are more than welcome. To contribute, please submit a pull request at https://github.com/lanl/LaGriT To ensure the best chance of acceptance for your pull request, please ensure that: All tests pass Your code is well documented and commented If adding new functionality, that unit tests have been included in the PR That the purpose and scope of your contributions are well explained in the PR","title":"Contribution Requirements"},{"location":"contributing.html#need-an-issue","text":"Visit the Issues page of LaGriT and search for tag 'Good First Issue'. These are great issues for someone unfamiliar with the codebase to work on.","title":"Need an Issue?"},{"location":"contributing.html#function-docstrings","text":"API documentation is generated using the pydoc-markdown package. Proper formatting is explained in the Syntax section of their documentation. As an example of proper formatting, def some_function ( self , required_param : str , opt_1 : str = None , opt_2 : int = 34 ): ''' Some function documentation. # Arguments required_param (str): Some description. # Optional Arguments opt_1 (str,None): Some description. # Raises ValueError: If *opt_1* does not end with `.md`. # Returns The object that is returned. '''","title":"Function Docstrings"},{"location":"contributing.html#contributor-license-agreement-cla","text":"If you are an external (non-LANL or LBNL) contributor, then in order to accept your pull request, we need you to submit a CLA. This license is for your protection as a Contributor as well as the protection of LANL and LaGriT users; it does not change your rights to use your own Contributions for any other purpose. Sign the CLA here: https://www.clahub.com/agreements/lanl/LaGriT","title":"Contributor License Agreement (CLA)"},{"location":"contributing.html#license","text":"By contributing to TINerator, you agree that your contributions will be licensed under the BSD-3 license.","title":"License"},{"location":"install.html","text":"Installation While TINerator is a relatively light module, it depends on several compiled libraries and packages. Consequently, it is recommended that you set up a Conda environment or virtual-env for managing TINerator: $ conda create --name tinerator python = 3 .5 $ source activate tinerator Note that you will have to re-run the source activate command on each new shell instance. Python Requirements TINerator requires Python 3.4+ and the following Python modules: Module URL RichDEM https://richdem.readthedocs.io Matplotlib https://matplotlib.org Numpy http://www.numpy.org SciPy https://www.scipy.org Rasterio https://rasterio.readthedocs.io Fiona https://fiona.readthedocs.io Elevation http://elevation.bopen.eu/en/stable/ PyLaGriT https://lanl.github.io/LaGriT/pylagrit/original/index.html With the exception of PyLaGriT, all modules will be automatically installed when running the python setup.py install command in TINerator. Warning On macOS, the default clang C/C++ compilers seem to fail on compilation of richdem . To circumvent this, export CC; export CXX to GNU GCC compilers. Building LaGriT + Exodus LaGriT is a mesh generation software suite built by Los Alamos National Laboratories, and it (wrapped by the Python library PyLaGriT) is the 'engine' driving TINerator. A LaGriT binary needs to be present on your system before proceeding. You can directly download a pre-built binary, or to build one yourself, run: git clone https://github.com/lanl/LaGriT.git && cd LaGriT make exodus make static && make test You will find the LaGriT executable in $( LAGRIT_ROOT_DIR ) /src/lagrit . For more information, please see the LaGriT installation documentation . Warning LaGriT does not currently support Windows compilation. Windows support is coming soon. Installing PyLaGriT PyLaGriT is a subfolder within the LaGriT repo. Navigate to $( LAGRIT_ROOT_DIR ) /PyLaGriT and run python setup.py install Next, create the file ~/.pylagritrc with the following text: lagrit_exe : 'path/to/lagrit/executable' where path/to/lagrit/executable is the path to the recently downloaded/installed LaGriT binary. For more information, visit the PyLaGriT installation page . Installing TINerator TINerator is currently a submodule within a branch on the LaGriT repository. Navigate to $( LAGRIT_ROOT_DIR ) and run git checkout tinerator cd tinerator python setup.py install TINerator should now be installed and ready for use. If you experience any difficulty building TINerator, please open an issue on the LaGriT Issues page . Installing MkDocs (Optional) Markdown files in the docs/ folder can be viewed with MkDocs. Build the following packages: pip install mkdocs pymdown-extensions mkdocs-material pygments pydoc-markdown and run, in the root directory of tinerator, mkdocs serve For more information, see Developer Notes . Next Steps Check out Examples to get started, or read the API for function and method documentation.","title":"Installation"},{"location":"install.html#installation","text":"While TINerator is a relatively light module, it depends on several compiled libraries and packages. Consequently, it is recommended that you set up a Conda environment or virtual-env for managing TINerator: $ conda create --name tinerator python = 3 .5 $ source activate tinerator Note that you will have to re-run the source activate command on each new shell instance.","title":"Installation"},{"location":"install.html#python-requirements","text":"TINerator requires Python 3.4+ and the following Python modules: Module URL RichDEM https://richdem.readthedocs.io Matplotlib https://matplotlib.org Numpy http://www.numpy.org SciPy https://www.scipy.org Rasterio https://rasterio.readthedocs.io Fiona https://fiona.readthedocs.io Elevation http://elevation.bopen.eu/en/stable/ PyLaGriT https://lanl.github.io/LaGriT/pylagrit/original/index.html With the exception of PyLaGriT, all modules will be automatically installed when running the python setup.py install command in TINerator. Warning On macOS, the default clang C/C++ compilers seem to fail on compilation of richdem . To circumvent this, export CC; export CXX to GNU GCC compilers.","title":"Python Requirements"},{"location":"install.html#building-lagrit-exodus","text":"LaGriT is a mesh generation software suite built by Los Alamos National Laboratories, and it (wrapped by the Python library PyLaGriT) is the 'engine' driving TINerator. A LaGriT binary needs to be present on your system before proceeding. You can directly download a pre-built binary, or to build one yourself, run: git clone https://github.com/lanl/LaGriT.git && cd LaGriT make exodus make static && make test You will find the LaGriT executable in $( LAGRIT_ROOT_DIR ) /src/lagrit . For more information, please see the LaGriT installation documentation . Warning LaGriT does not currently support Windows compilation. Windows support is coming soon.","title":"Building LaGriT + Exodus"},{"location":"install.html#installing-pylagrit","text":"PyLaGriT is a subfolder within the LaGriT repo. Navigate to $( LAGRIT_ROOT_DIR ) /PyLaGriT and run python setup.py install Next, create the file ~/.pylagritrc with the following text: lagrit_exe : 'path/to/lagrit/executable' where path/to/lagrit/executable is the path to the recently downloaded/installed LaGriT binary. For more information, visit the PyLaGriT installation page .","title":"Installing PyLaGriT"},{"location":"install.html#installing-tinerator","text":"TINerator is currently a submodule within a branch on the LaGriT repository. Navigate to $( LAGRIT_ROOT_DIR ) and run git checkout tinerator cd tinerator python setup.py install TINerator should now be installed and ready for use. If you experience any difficulty building TINerator, please open an issue on the LaGriT Issues page .","title":"Installing TINerator"},{"location":"install.html#installing-mkdocs-optional","text":"Markdown files in the docs/ folder can be viewed with MkDocs. Build the following packages: pip install mkdocs pymdown-extensions mkdocs-material pygments pydoc-markdown and run, in the root directory of tinerator, mkdocs serve For more information, see Developer Notes .","title":"Installing MkDocs (Optional)"},{"location":"install.html#next-steps","text":"Check out Examples to get started, or read the API for function and method documentation.","title":"Next Steps"},{"location":"license.html","text":"License (BSD) Copyright \u00a9 2019, Triad National Security, LLC. All rights reserved. Copyright 2019. Triad National Security, LLC. This software was produced under U.S. Government contract DE-AC52-06NA25396 for Los Alamos National Laboratory (LANL), which is operated by Triad National Security, LLC for the U.S. Department of Energy. The U.S. Government has rights to use, reproduce, and distribute this software. NEITHER THE GOVERNMENT NOR TRIAD NATIONAL SECURITY, LLC MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LIABILITY FOR THE USE OF THIS SOFTWARE. If software is modified to produce derivative works, such modified software should be clearly marked, so as not to confuse it with the version available from LANL. Additionally, redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of Triad National Security, LLC, Los Alamos National Laboratory, LANL, the U.S. Government, nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY TRIAD NATIONAL SECURITY, LLC AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL TRIAD NATIONAL SECURITY, LLC OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"license.html#license-bsd","text":"Copyright \u00a9 2019, Triad National Security, LLC. All rights reserved. Copyright 2019. Triad National Security, LLC. This software was produced under U.S. Government contract DE-AC52-06NA25396 for Los Alamos National Laboratory (LANL), which is operated by Triad National Security, LLC for the U.S. Department of Energy. The U.S. Government has rights to use, reproduce, and distribute this software. NEITHER THE GOVERNMENT NOR TRIAD NATIONAL SECURITY, LLC MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LIABILITY FOR THE USE OF THIS SOFTWARE. If software is modified to produce derivative works, such modified software should be clearly marked, so as not to confuse it with the version available from LANL. Additionally, redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of Triad National Security, LLC, Los Alamos National Laboratory, LANL, the U.S. Government, nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY TRIAD NATIONAL SECURITY, LLC AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL TRIAD NATIONAL SECURITY, LLC OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License (BSD)"},{"location":"release_notes.html","text":"Release Notes 0.3.0 (01/25/19) - Massive documentation updates 0.2.0 (DATE) - Full change from LaGriT infiles to PyLaGriT syntax 0.1.1 (08/12/18) - Minor bug fixes and beginning of documentation. 0.1.0 (08/10/18) - Initial release.","title":"Release Notes"},{"location":"release_notes.html#release-notes","text":"0.3.0 (01/25/19) - Massive documentation updates 0.2.0 (DATE) - Full change from LaGriT infiles to PyLaGriT syntax 0.1.1 (08/12/18) - Minor bug fixes and beginning of documentation. 0.1.0 (08/10/18) - Initial release.","title":"Release Notes"},{"location":"api/index.html","text":"TINerator API The complete list of user-facing functions, classes, and methods are listed here. Starting Points tinerator.DEM - the main DEM class and member functions tinerator.load - loading a DEM instance from various formats tinerator.dump - writing a DEM object to various formats tinerator.plot - 2D and 3D visualization functions","title":"Index"},{"location":"api/index.html#tinerator-api","text":"The complete list of user-facing functions, classes, and methods are listed here.","title":"TINerator API"},{"location":"api/index.html#starting-points","text":"tinerator.DEM - the main DEM class and member functions tinerator.load - loading a DEM instance from various formats tinerator.dump - writing a DEM object to various formats tinerator.plot - 2D and 3D visualization functions","title":"Starting Points"},{"location":"api/boundary.html","text":"tinerator.boundary orderPointsClockwise orderPointsClockwise ( points : numpy . ndarray , opt : str = 'polar' , clockwise : bool = True ) Given a 2D array of points, this function reorders points clockwise. Available methods are: 'angle', to sort by angle, 'polar', to sort by polar coordinates, and 'nearest_neighbor', to sort by nearest neighbor. Arguments points (np.ndarray) : Array of unsorted points opt (str) : Sorting method clockwise (bool) : order points clockwise or counterclockwise Returns Sorted points imageErosionBoundary imageErosionBoundary ( A , nil_value , distance , cell_size = None , xll_corner = 0 , yll_corner = 0 ) Blazing fast way to create an accurate DEM boundary. Currently, there is no way to seperate nodes with a delta-x. As such, this function is not called anywhere within this package. Once that is implemented, this function will depreciate squareTraceBoundary(). Arguments A (np.ndarray) : matrix to perform boundary analysis on nil_value (float) : value characterizing undefined array values distance (float) : spacing between boundary nodes Returns boundary nodes rectangularBoundary rectangularBoundary ( bbox : list , spacing : float ) Generates a rectangular boundary with evenly spaced points. bbox should be a list of values in the following format: min(x), max(x), min(y), max(y) Arguments bbox (list ) : bounding box coordinates spacing (float) : spacing between adjacent nodes Returns Array of interpolated bounding box values squareTraceBoundary squareTraceBoundary ( A , NDV , dist = 10.0 ) Uses a square-tracing algorithm to quickly find a set of points composing the boundary at the interface of data and \"empty\" (noDataValue) cells in a DEM matrix. The optional parameter 'dist' denotes the seperation the points should have between each other. A smaller value will result in more points being created. For more information, visit this page . Arguments A (np.ndarray) : matrix to perform boundary analysis on NDV (float) : value characterizing undefined array values dist (float) : spacing between boundary nodes Returns Boundary nodes","title":"boundary"},{"location":"api/boundary.html#tineratorboundary","text":"","title":"tinerator.boundary"},{"location":"api/boundary.html#orderpointsclockwise","text":"orderPointsClockwise ( points : numpy . ndarray , opt : str = 'polar' , clockwise : bool = True ) Given a 2D array of points, this function reorders points clockwise. Available methods are: 'angle', to sort by angle, 'polar', to sort by polar coordinates, and 'nearest_neighbor', to sort by nearest neighbor. Arguments points (np.ndarray) : Array of unsorted points opt (str) : Sorting method clockwise (bool) : order points clockwise or counterclockwise Returns Sorted points","title":"orderPointsClockwise"},{"location":"api/boundary.html#imageerosionboundary","text":"imageErosionBoundary ( A , nil_value , distance , cell_size = None , xll_corner = 0 , yll_corner = 0 ) Blazing fast way to create an accurate DEM boundary. Currently, there is no way to seperate nodes with a delta-x. As such, this function is not called anywhere within this package. Once that is implemented, this function will depreciate squareTraceBoundary(). Arguments A (np.ndarray) : matrix to perform boundary analysis on nil_value (float) : value characterizing undefined array values distance (float) : spacing between boundary nodes Returns boundary nodes","title":"imageErosionBoundary"},{"location":"api/boundary.html#rectangularboundary","text":"rectangularBoundary ( bbox : list , spacing : float ) Generates a rectangular boundary with evenly spaced points. bbox should be a list of values in the following format: min(x), max(x), min(y), max(y) Arguments bbox (list ) : bounding box coordinates spacing (float) : spacing between adjacent nodes Returns Array of interpolated bounding box values","title":"rectangularBoundary"},{"location":"api/boundary.html#squaretraceboundary","text":"squareTraceBoundary ( A , NDV , dist = 10.0 ) Uses a square-tracing algorithm to quickly find a set of points composing the boundary at the interface of data and \"empty\" (noDataValue) cells in a DEM matrix. The optional parameter 'dist' denotes the seperation the points should have between each other. A smaller value will result in more points being created. For more information, visit this page . Arguments A (np.ndarray) : matrix to perform boundary analysis on NDV (float) : value characterizing undefined array values dist (float) : spacing between boundary nodes Returns Boundary nodes","title":"squareTraceBoundary"},{"location":"api/config.html","text":"tinerator.config CONFIGURATION FILE FOR TINERATOR activate_virtual_framebuffer activate_virtual_framebuffer () Activates a virtual (headless) framebuffer for rendering 3D scenes via VTK. Most critically, this function is useful when this code is being run in a Dockerized notebook, or over a server without X forwarding. Requires the following packages: sudo apt-get install libgl1-mesa-dev xvfb","title":"config"},{"location":"api/config.html#tineratorconfig","text":"CONFIGURATION FILE FOR TINERATOR","title":"tinerator.config"},{"location":"api/config.html#activate_virtual_framebuffer","text":"activate_virtual_framebuffer () Activates a virtual (headless) framebuffer for rendering 3D scenes via VTK. Most critically, this function is useful when this code is being run in a Dockerized notebook, or over a server without X forwarding. Requires the following packages: sudo apt-get install libgl1-mesa-dev xvfb","title":"activate_virtual_framebuffer"},{"location":"api/dem.html","text":"tinerator.dem_class DEM DEM ( self , filepath : str , lagrit_exe : str = None ) This is the 'main' class of TINerator, and stores all DEM and GIS data related to a particular project. Attributes filepath (str) : Filepath to DEM raster lagrit_exe (str,None) : Optional filepath to LaGriT binary. If PyLaGriT is configured correctly, this should be unnecessary. change_ndv DEM . change_ndv ( self , ndv : float ) Changes no_data_value of the DEM object. This should be used instead of resetting dem.no_data_value manually, as it makes deeper changes. Example dem . change_ndv ( - 9999. ) print ( dem . no_data_value ) # -9999.0 Arguments ndv (float) : New no_data_value set_to_ndv DEM . set_to_ndv ( self , value : float ) Changes all occurances of value in the DEM data to no_data_value . Example dem.set_to_ndv(dem.dem[0][0]) print(dem.dem == dem.no_data_value) # True Arguments value (float) : raster value to replace set_verbosity DEM . set_verbosity ( self , verb_level : int , filename : str = None ) Set the verbosity level of printed output. NOTHING : Nothing (except warnings and related) INFO : Log output FULL : Log output and LaGriT output DEBUG : Log output, LaGriT output, and turns on debug mode Each of these verbosity levels are variables in tinerator.config . Example dem . set_verbosity ( tinerator . config . FULL ) Arguments verb_level (int) : verbosity level filename (str) : file to write log output to fill_depressions DEM . fill_depressions ( self , fill_depressions : bool = True , fill_flats : bool = True ) Fills flats and depressions on DEM. On meshes intended to be high- resolution, leaving flats and depressions untouched may cause solver issues. This method should be called before generating a triplane. Arguments fill_depressions (bool) : fill pits and depressions on DEM fill_flats (bool) : fill flats on DEM Example dem1 = tin . load . from_file ( \"example.asc\" ) dem2 = tin . load . from_file ( \"example.asc\" ) dem1 . fill_depressions () plt . imshow ( dem1 . dem - dem2 . dem ) plt . show () This example shows the different in topology between a post-processed and unprocessed DEM. watershed_delineation DEM . watershed_delineation ( self , threshold : float , method : str = 'D8' , exponent : float = None , interactive : bool = False ) Performs watershed delineation on a DEM and returns a set of points corresponding to the feature. Available methods are: D8 D4 Rho8 Rho4 Dinf Quinn Holmgren Freeman Arguments threshold (float) : threshold for determining feature from noise method (str) : Flow calculation method interactive (bool) : if True and function is called within a Jupyter notebook, then function params can be controlled with sliders Returns Polyline of feature as ordered (x,y) pairs build_uniform_triplane DEM . build_uniform_triplane ( self , edge_length : float , smooth_boundary : bool = False , flip : str = 'y' , apply_elevation : bool = True , outfile : str = None , rectangular_boundary : bool = False , boundary_distance : float = None , interactive : bool = False ) Generates a triplane with uniformly sized elements. Attributes edge_length (float) : desired lengths for triangle edges flip (str) : flips array of the elevation raster along a given axis (x,y,xy) smooth_boundary (bool) : If True, smooth the DEM boundary for better interpolation apply_elevation (bool) : If True, interpolate DEM elevations onto surface mesh outfile (str) : filepath to save generated mesh to rectangular_boundary (bool) : set to true if the DEM domain is rectangular boundary_distance (float) : Overrides edge length and manually sets spacing between boundary nodes interactive (bool) : if True and function is called within a Jupyter notebook, then function params can be controlled with sliders Returns PyLaGriT mesh object build_refined_triplane DEM . build_refined_triplane ( self , min_edge_length : float , max_edge_length : float , outfile : str = None , apply_elevation : bool = True , slope : float = 2.0 , refine_dist : float = 0.5 , flip : str = 'y' , smooth_boundary : bool = False , rectangular_boundary : bool = False , boundary_distance : float = None , interactive : bool = False ) Generates a refined triangular mesh, with a minimum refinement length defined by h. Attributes min_edge_length (float) : minimum triangle edge lengths max_edge_length (float) : maximum triangle edge lengths outfile (str) : Filepath to save mesh to apply_elevation (bool) : If True, interpolate DEM elevations onto surface mesh slope (float) : slope of refine function refine_dist (float) : Threshold for minimum distance in distance map flip (str) : flips array of the elevation raster along a given axis ( 'x','y','xy' ) smooth_boundary (bool) : If True, smooth the DEM boundary for better interpolation rectangular_boundary (bool) : set to true if the DEM domain is rectangular boundary_distance (float) : Overrides edge length and manually sets spacing between boundary nodes interactive (bool) : if True and function is called within a Jupyter notebook, then function params can be controlled with sliders Returns PyLaGriT mesh object build_layered_mesh DEM . build_layered_mesh ( self , layers , matids = None , outfile : str = None ) Builds a layered mesh from a triplane. Arguments layers (list ) : List of sequential layer thicknesses matids (list ) : List of material IDs to set each respective layer to outfile (str) : Filepath to save mesh to Example layers = [ 1. , 1. , 3. , 10. , 2. ] matids = [ 1 , 1 , 2 , 1 , 3 ] dem . build_layered_mesh ( layers , matids = matids ) add_attribute DEM . add_attribute ( self , data , layers = None , attribute_name = None , outfile = None , dtype = None ) Adds an attribute to the stacked mesh, over one or more layers. Default is all. Data must be an NxM matrix - it does not necessarily have to be the same size at the DEM, but is recommended as it will be streched to span the domain of it. attribute_name will be the element-based attribute the data is written into. The default is 'material ID' ( itetclr ), but can be changed to any [a-z][A-Z][0-9] string (outside of reserved LaGriT keywords). Arguments data (np.ndarray) : NxM matrix of data to be written as matrix layers (list ) : Layer IDs to write attributes to. Defaults to 'all'. attribute_name (str) : Attribute name to store data in. Defaults to material ID outfile (str) : Filename to write mesh to dtype (type) : Data type of elements in data ( float or int ) map_function_to_attribute DEM . map_function_to_attribute ( self , operator = '+' , layers = None , attribute_name = None , outfile = None , fn =< function DEM .< lambda > at 0x1c337f2400 > ) Maps a function and on operator onto mesh data. The function fn should take one parameter: the current layer number. The operator will perform on the data and function result. In other words, the new attribute data will be a result of: attribute_data(layer) = attribute_data [operation] fn(layer) For fn = lambda layer: layer*100 and operator + , attribute_data(layer) = attribute_data + layer*100 meaning that if a selection of attribute data is [1,3,5,10,12...] then, with operator '+' and lambda layer: layer*100, layer 1: [101,103,105,110,112...] layer 2: [201,203,205,210,212...] layer 3: [301,103,305,310,312...] ... getBoundingBox DEM . getBoundingBox ( self , mpl_style : bool = True ) Returns the bounding box (or extent) of the DEM domain. By default, the format of the extent returned is: (x_min,x_max,y_min,y_max) By setting mpl_style=False , the format changes to: (x_min,y_min,x_max,y_max) Extent units are relative to the parent DEM coordinate system. Arguments mpl_style (bool) : Change the format of the returned extent Returns DEM domain bounding box plot_dem DEM . plot_dem ( self , hillshade : bool = False , plot_out : str = None ) Plots the loaded DEM. plot_boundary DEM . plot_boundary ( self ) Plots the DEM domain boundary (if available). plot_feature DEM . plot_feature ( self ) Displays the feature captured by performing watershed delination (if available).","title":"DEM"},{"location":"api/dem.html#tineratordem_class","text":"","title":"tinerator.dem_class"},{"location":"api/dem.html#dem","text":"DEM ( self , filepath : str , lagrit_exe : str = None ) This is the 'main' class of TINerator, and stores all DEM and GIS data related to a particular project. Attributes filepath (str) : Filepath to DEM raster lagrit_exe (str,None) : Optional filepath to LaGriT binary. If PyLaGriT is configured correctly, this should be unnecessary.","title":"DEM"},{"location":"api/dem.html#change_ndv","text":"DEM . change_ndv ( self , ndv : float ) Changes no_data_value of the DEM object. This should be used instead of resetting dem.no_data_value manually, as it makes deeper changes. Example dem . change_ndv ( - 9999. ) print ( dem . no_data_value ) # -9999.0 Arguments ndv (float) : New no_data_value","title":"change_ndv"},{"location":"api/dem.html#set_to_ndv","text":"DEM . set_to_ndv ( self , value : float ) Changes all occurances of value in the DEM data to no_data_value . Example dem.set_to_ndv(dem.dem[0][0]) print(dem.dem == dem.no_data_value) # True Arguments value (float) : raster value to replace","title":"set_to_ndv"},{"location":"api/dem.html#set_verbosity","text":"DEM . set_verbosity ( self , verb_level : int , filename : str = None ) Set the verbosity level of printed output. NOTHING : Nothing (except warnings and related) INFO : Log output FULL : Log output and LaGriT output DEBUG : Log output, LaGriT output, and turns on debug mode Each of these verbosity levels are variables in tinerator.config . Example dem . set_verbosity ( tinerator . config . FULL ) Arguments verb_level (int) : verbosity level filename (str) : file to write log output to","title":"set_verbosity"},{"location":"api/dem.html#fill_depressions","text":"DEM . fill_depressions ( self , fill_depressions : bool = True , fill_flats : bool = True ) Fills flats and depressions on DEM. On meshes intended to be high- resolution, leaving flats and depressions untouched may cause solver issues. This method should be called before generating a triplane. Arguments fill_depressions (bool) : fill pits and depressions on DEM fill_flats (bool) : fill flats on DEM Example dem1 = tin . load . from_file ( \"example.asc\" ) dem2 = tin . load . from_file ( \"example.asc\" ) dem1 . fill_depressions () plt . imshow ( dem1 . dem - dem2 . dem ) plt . show () This example shows the different in topology between a post-processed and unprocessed DEM.","title":"fill_depressions"},{"location":"api/dem.html#watershed_delineation","text":"DEM . watershed_delineation ( self , threshold : float , method : str = 'D8' , exponent : float = None , interactive : bool = False ) Performs watershed delineation on a DEM and returns a set of points corresponding to the feature. Available methods are: D8 D4 Rho8 Rho4 Dinf Quinn Holmgren Freeman Arguments threshold (float) : threshold for determining feature from noise method (str) : Flow calculation method interactive (bool) : if True and function is called within a Jupyter notebook, then function params can be controlled with sliders Returns Polyline of feature as ordered (x,y) pairs","title":"watershed_delineation"},{"location":"api/dem.html#build_uniform_triplane","text":"DEM . build_uniform_triplane ( self , edge_length : float , smooth_boundary : bool = False , flip : str = 'y' , apply_elevation : bool = True , outfile : str = None , rectangular_boundary : bool = False , boundary_distance : float = None , interactive : bool = False ) Generates a triplane with uniformly sized elements. Attributes edge_length (float) : desired lengths for triangle edges flip (str) : flips array of the elevation raster along a given axis (x,y,xy) smooth_boundary (bool) : If True, smooth the DEM boundary for better interpolation apply_elevation (bool) : If True, interpolate DEM elevations onto surface mesh outfile (str) : filepath to save generated mesh to rectangular_boundary (bool) : set to true if the DEM domain is rectangular boundary_distance (float) : Overrides edge length and manually sets spacing between boundary nodes interactive (bool) : if True and function is called within a Jupyter notebook, then function params can be controlled with sliders Returns PyLaGriT mesh object","title":"build_uniform_triplane"},{"location":"api/dem.html#build_refined_triplane","text":"DEM . build_refined_triplane ( self , min_edge_length : float , max_edge_length : float , outfile : str = None , apply_elevation : bool = True , slope : float = 2.0 , refine_dist : float = 0.5 , flip : str = 'y' , smooth_boundary : bool = False , rectangular_boundary : bool = False , boundary_distance : float = None , interactive : bool = False ) Generates a refined triangular mesh, with a minimum refinement length defined by h. Attributes min_edge_length (float) : minimum triangle edge lengths max_edge_length (float) : maximum triangle edge lengths outfile (str) : Filepath to save mesh to apply_elevation (bool) : If True, interpolate DEM elevations onto surface mesh slope (float) : slope of refine function refine_dist (float) : Threshold for minimum distance in distance map flip (str) : flips array of the elevation raster along a given axis ( 'x','y','xy' ) smooth_boundary (bool) : If True, smooth the DEM boundary for better interpolation rectangular_boundary (bool) : set to true if the DEM domain is rectangular boundary_distance (float) : Overrides edge length and manually sets spacing between boundary nodes interactive (bool) : if True and function is called within a Jupyter notebook, then function params can be controlled with sliders Returns PyLaGriT mesh object","title":"build_refined_triplane"},{"location":"api/dem.html#build_layered_mesh","text":"DEM . build_layered_mesh ( self , layers , matids = None , outfile : str = None ) Builds a layered mesh from a triplane. Arguments layers (list ) : List of sequential layer thicknesses matids (list ) : List of material IDs to set each respective layer to outfile (str) : Filepath to save mesh to Example layers = [ 1. , 1. , 3. , 10. , 2. ] matids = [ 1 , 1 , 2 , 1 , 3 ] dem . build_layered_mesh ( layers , matids = matids )","title":"build_layered_mesh"},{"location":"api/dem.html#add_attribute","text":"DEM . add_attribute ( self , data , layers = None , attribute_name = None , outfile = None , dtype = None ) Adds an attribute to the stacked mesh, over one or more layers. Default is all. Data must be an NxM matrix - it does not necessarily have to be the same size at the DEM, but is recommended as it will be streched to span the domain of it. attribute_name will be the element-based attribute the data is written into. The default is 'material ID' ( itetclr ), but can be changed to any [a-z][A-Z][0-9] string (outside of reserved LaGriT keywords). Arguments data (np.ndarray) : NxM matrix of data to be written as matrix layers (list ) : Layer IDs to write attributes to. Defaults to 'all'. attribute_name (str) : Attribute name to store data in. Defaults to material ID outfile (str) : Filename to write mesh to dtype (type) : Data type of elements in data ( float or int )","title":"add_attribute"},{"location":"api/dem.html#map_function_to_attribute","text":"DEM . map_function_to_attribute ( self , operator = '+' , layers = None , attribute_name = None , outfile = None , fn =< function DEM .< lambda > at 0x1c337f2400 > ) Maps a function and on operator onto mesh data. The function fn should take one parameter: the current layer number. The operator will perform on the data and function result. In other words, the new attribute data will be a result of: attribute_data(layer) = attribute_data [operation] fn(layer) For fn = lambda layer: layer*100 and operator + , attribute_data(layer) = attribute_data + layer*100 meaning that if a selection of attribute data is [1,3,5,10,12...] then, with operator '+' and lambda layer: layer*100, layer 1: [101,103,105,110,112...] layer 2: [201,203,205,210,212...] layer 3: [301,103,305,310,312...] ...","title":"map_function_to_attribute"},{"location":"api/dem.html#getboundingbox","text":"DEM . getBoundingBox ( self , mpl_style : bool = True ) Returns the bounding box (or extent) of the DEM domain. By default, the format of the extent returned is: (x_min,x_max,y_min,y_max) By setting mpl_style=False , the format changes to: (x_min,y_min,x_max,y_max) Extent units are relative to the parent DEM coordinate system. Arguments mpl_style (bool) : Change the format of the returned extent Returns DEM domain bounding box","title":"getBoundingBox"},{"location":"api/dem.html#plot_dem","text":"DEM . plot_dem ( self , hillshade : bool = False , plot_out : str = None ) Plots the loaded DEM.","title":"plot_dem"},{"location":"api/dem.html#plot_boundary","text":"DEM . plot_boundary ( self ) Plots the DEM domain boundary (if available).","title":"plot_boundary"},{"location":"api/dem.html#plot_feature","text":"DEM . plot_feature ( self ) Displays the feature captured by performing watershed delination (if available).","title":"plot_feature"},{"location":"api/developernotes.html","text":"For Developers Project To-Do's To see current bug fixes and issues under development, visit the Issues page (label:tinerator) . To request a feature or to add a bug report, submit a ticket on the LaGriT Issues page with label: tinerator. Contributing Best practices on contributing to this project, including formatting API docstrings, can be found in the Contributing page. Code Formatting Use the Black code formatter to ensure that code fits within a standardized style. Documentation Compilation Documentation is found in the tinerator/docs folder and is written in Markdown. The static site is generated by MkDocs using the Materials theme . Required MkDocs Extensions Package Command MathJax pip install pymdown-extensions Codehilite pip install pygments Materials theme pip install mkdocs-material API Generation To generate API documents, you will need pydoc-markdown . This can be installed via: pip install pydoc-markdown Then, run: ./pydocmd_build.sh in the docs/api/ directory. Viewing the Site After all requirements are resolved, run mkdocs serve to start the local server. Navigate your web browser to the local server address (i.e., http://127.0.0.1:8000 ) to view. MkDocs will automatically reload the static site upon any detected file change within the docs/ folder. HTML files can be generated by using mkdocs build . Note This manual process will eventually be phased out in support for TravisCI-based continuous deployment. Pull requests on this topic are welcome.","title":"For Developers"},{"location":"api/developernotes.html#for-developers","text":"","title":"For Developers"},{"location":"api/developernotes.html#project-to-dos","text":"To see current bug fixes and issues under development, visit the Issues page (label:tinerator) . To request a feature or to add a bug report, submit a ticket on the LaGriT Issues page with label: tinerator.","title":"Project To-Do's"},{"location":"api/developernotes.html#contributing","text":"Best practices on contributing to this project, including formatting API docstrings, can be found in the Contributing page.","title":"Contributing"},{"location":"api/developernotes.html#code-formatting","text":"Use the Black code formatter to ensure that code fits within a standardized style.","title":"Code Formatting"},{"location":"api/developernotes.html#documentation-compilation","text":"Documentation is found in the tinerator/docs folder and is written in Markdown. The static site is generated by MkDocs using the Materials theme .","title":"Documentation Compilation"},{"location":"api/developernotes.html#required-mkdocs-extensions","text":"Package Command MathJax pip install pymdown-extensions Codehilite pip install pygments Materials theme pip install mkdocs-material","title":"Required MkDocs Extensions"},{"location":"api/developernotes.html#api-generation","text":"To generate API documents, you will need pydoc-markdown . This can be installed via: pip install pydoc-markdown Then, run: ./pydocmd_build.sh in the docs/api/ directory.","title":"API Generation"},{"location":"api/developernotes.html#viewing-the-site","text":"After all requirements are resolved, run mkdocs serve to start the local server. Navigate your web browser to the local server address (i.e., http://127.0.0.1:8000 ) to view. MkDocs will automatically reload the static site upon any detected file change within the docs/ folder. HTML files can be generated by using mkdocs build . Note This manual process will eventually be phased out in support for TravisCI-based continuous deployment. Pull requests on this topic are welcome.","title":"Viewing the Site"},{"location":"api/dump.html","text":"tinerator.dump to_exodus to_exodus ( dem_object , outfile : str , facesets : list = None , mesh : str = None ) Writes a mesh in the Exodus file format. Note that to export with facesets, the mesh must have depth - that is, build_layered_mesh() must have been called first. Arguments dem_object (tinerator.DEM) : a Tinerator DEM object outfile (str) : path to save Exodus mesh to facesets (list) : a list containing Faceset objects mesh (str) : type of mesh to export ('surface' or 'prism') to_avs to_avs ( dem_object , outfile : str , mesh_object : str = None ) Writes a mesh in the AVS-UCD file format. Note that facesets cannot be exported. Arguments dem_object (tinerator.DEM) : a Tinerator DEM object outfile (str) : path to save Exodus mesh to mesh (str) : type of mesh to export ('surface' or 'prism')","title":"dump"},{"location":"api/dump.html#tineratordump","text":"","title":"tinerator.dump"},{"location":"api/dump.html#to_exodus","text":"to_exodus ( dem_object , outfile : str , facesets : list = None , mesh : str = None ) Writes a mesh in the Exodus file format. Note that to export with facesets, the mesh must have depth - that is, build_layered_mesh() must have been called first. Arguments dem_object (tinerator.DEM) : a Tinerator DEM object outfile (str) : path to save Exodus mesh to facesets (list) : a list containing Faceset objects mesh (str) : type of mesh to export ('surface' or 'prism')","title":"to_exodus"},{"location":"api/dump.html#to_avs","text":"to_avs ( dem_object , outfile : str , mesh_object : str = None ) Writes a mesh in the AVS-UCD file format. Note that facesets cannot be exported. Arguments dem_object (tinerator.DEM) : a Tinerator DEM object outfile (str) : path to save Exodus mesh to mesh (str) : type of mesh to export ('surface' or 'prism')","title":"to_avs"},{"location":"api/facesets.html","text":"tinerator.facesets Faceset Faceset ( self , fs_type , data , metadata = None ) Object that stores faceset formatting data from_elevations from_elevations ( heights : list , keep_body : bool = False ) -> tinerator . facesets . Faceset Facesets are generated and return from the heights array: a faceset will be created in the layers defined by heights . For example, with the heights array heights = [ 50. , 100. , 150. , 200. ] five facesets will be created: all surface elements lower than 50 meters all surface elements between 50 and 100 meters all surface elements between 100 and 150 meters all surface elements between 150 and 200 meters all surface elements greater than 200 meters Another approach is to split the elevation range into layers using properties min_z and max_z : >>> print ( 'Elevation range = ({0},{1})' . format ( dem . min_z , dem . max_z )) Elevation range = ( 2365.3 , 3942.2 ) >>> heights = np . linspace ( dem . min_z , dem . max_z , 10 ) >>> print ( heights ) array ([ 2365.3 , 2540.51111111 , 2715.72222222 , 2890.93333333 , 3066.14444444 , 3241.35555556 , 3416.56666667 , 3591.77777778 , 3766.98888889 , 3942.2 ]) Arguments dem_object (tinerator.DEM) : an instance of tinerator.DEM class heights (list ) : a list of vertical (z) layers keep_body (bool) : when True, elevation-based facesets are applied across the entire mesh . When False, elevation-based facesets only apply to the top layer. Returns A Faceset object sidesets sidesets ( coords : numpy . ndarray , top_layer : bool = False ) -> tinerator . facesets . Faceset Operates on side facesets only . Constructs discretized side facesets based on the coords array. coords should contain one [x,y] pairs at each point a new sideset should be defined. Further, these points must be ordered clockwise. For an example, consider a square that spans 0 to 1 in both the x and y planes. The top, right, and bottom facesets are represented in the drawing below: 1 _______ | | | | 2 | | ------- 3 To construct coords properly, the array would look like: [0.,1.], # top [1.,1.], # right [1.,0.] # bottom Note the points are ordered clock-wise. By default, these sidesets will be applied to all layers. We can apply these sidesets to only the top layer (to capture an outlet, for example) by using flag top_layer=True . Arguments coords (np.ndarray) : clockwise array of points indicating faceset junctions top_layer (bool) : when True, apply to only the top layer. when False, apply to all layers. Returns A Faceset class instance basic basic ( has_top : bool = True , has_sides : bool = True , has_bottom : bool = True ) -> tinerator . facesets . Faceset Generates basic facesets. Using the flags, you can define one or more of: Top faceset Side faceset Bottom faceset Arguments has_top (bool) : generate a top faceset has_sides (bool) : generate a sides faceset has_bottom (bool) : generate a bottom faceset Returns A Faceset class instance write_facesets write_facesets ( dem_object , facesets ) Given a DEM object and a list of Faceset class objects, this generates the corresponding faceset files. This function should not be used by an end-user unless they want AVS2 faceset files unconnected to an Exodus mesh. Arguments dem_object (tinerator.DEM) : DEM class instance to operate from facesets (list ) : list of Faceset objects describing generation steps Returns A list containing generated faceset files","title":"facesets"},{"location":"api/facesets.html#tineratorfacesets","text":"","title":"tinerator.facesets"},{"location":"api/facesets.html#faceset","text":"Faceset ( self , fs_type , data , metadata = None ) Object that stores faceset formatting data","title":"Faceset"},{"location":"api/facesets.html#from_elevations","text":"from_elevations ( heights : list , keep_body : bool = False ) -> tinerator . facesets . Faceset Facesets are generated and return from the heights array: a faceset will be created in the layers defined by heights . For example, with the heights array heights = [ 50. , 100. , 150. , 200. ] five facesets will be created: all surface elements lower than 50 meters all surface elements between 50 and 100 meters all surface elements between 100 and 150 meters all surface elements between 150 and 200 meters all surface elements greater than 200 meters Another approach is to split the elevation range into layers using properties min_z and max_z : >>> print ( 'Elevation range = ({0},{1})' . format ( dem . min_z , dem . max_z )) Elevation range = ( 2365.3 , 3942.2 ) >>> heights = np . linspace ( dem . min_z , dem . max_z , 10 ) >>> print ( heights ) array ([ 2365.3 , 2540.51111111 , 2715.72222222 , 2890.93333333 , 3066.14444444 , 3241.35555556 , 3416.56666667 , 3591.77777778 , 3766.98888889 , 3942.2 ]) Arguments dem_object (tinerator.DEM) : an instance of tinerator.DEM class heights (list ) : a list of vertical (z) layers keep_body (bool) : when True, elevation-based facesets are applied across the entire mesh . When False, elevation-based facesets only apply to the top layer. Returns A Faceset object","title":"from_elevations"},{"location":"api/facesets.html#sidesets","text":"sidesets ( coords : numpy . ndarray , top_layer : bool = False ) -> tinerator . facesets . Faceset Operates on side facesets only . Constructs discretized side facesets based on the coords array. coords should contain one [x,y] pairs at each point a new sideset should be defined. Further, these points must be ordered clockwise. For an example, consider a square that spans 0 to 1 in both the x and y planes. The top, right, and bottom facesets are represented in the drawing below: 1 _______ | | | | 2 | | ------- 3 To construct coords properly, the array would look like: [0.,1.], # top [1.,1.], # right [1.,0.] # bottom Note the points are ordered clock-wise. By default, these sidesets will be applied to all layers. We can apply these sidesets to only the top layer (to capture an outlet, for example) by using flag top_layer=True . Arguments coords (np.ndarray) : clockwise array of points indicating faceset junctions top_layer (bool) : when True, apply to only the top layer. when False, apply to all layers. Returns A Faceset class instance","title":"sidesets"},{"location":"api/facesets.html#basic","text":"basic ( has_top : bool = True , has_sides : bool = True , has_bottom : bool = True ) -> tinerator . facesets . Faceset Generates basic facesets. Using the flags, you can define one or more of: Top faceset Side faceset Bottom faceset Arguments has_top (bool) : generate a top faceset has_sides (bool) : generate a sides faceset has_bottom (bool) : generate a bottom faceset Returns A Faceset class instance","title":"basic"},{"location":"api/facesets.html#write_facesets","text":"write_facesets ( dem_object , facesets ) Given a DEM object and a list of Faceset class objects, this generates the corresponding faceset files. This function should not be used by an end-user unless they want AVS2 faceset files unconnected to an Exodus mesh. Arguments dem_object (tinerator.DEM) : DEM class instance to operate from facesets (list ) : list of Faceset objects describing generation steps Returns A list containing generated faceset files","title":"write_facesets"},{"location":"api/load.html","text":"tinerator.load from_file from_file ( filepath : str , lagrit_exe = None ) Loads a DEM raster from a local filepath and returns a tinerator.DEM instance. Arguments filepath (str) : Filepath to DEM raster from_matrix from_matrix ( array : numpy . ndarray , xllcorner = 0.0 , yllcorner = 0.0 , cell_size = 10.0 , no_data_value =- 9999 ) Creates a TINerator DEM instance from a Numpy 2D matrix. Arguments array (np.ndarray) : NxM Numpy matrix * xllcorner (int,float) : lower-left raster x-coordinate * yllcorner (int,float) : lower-left raster y-coordinate * cell_size (int,float) : raster cell size * no_data_value (int,float) : raster null value __ Note__: no_data_value cannot be np.nan. Returns tinerator.DEM instance from_coordinates from_coordinates ( bounding_box , outfile = None , SRTM_30 = True ) Downloads and returns a DEM from a geodetic coordinate bounding box. This function is powered by the elevation package, and sources rasters from either SRTM 30m Global 1 arc second V003 elaborated by NASA and NGA, or SRTM 90m Digital Elevation Database v4.1 elaborated by CGIAR-CSI. Note that note bounding box values must be latitude and longitude values given as: (left, bottom, right, top) . (Specifically, geodetic coordinates in the WGS84 reference system EPSG:4326.) Note: if this method fails with error 'Too many tiles', try again with SRTM_30=False . Arguments bounding_box (tuple) : Lat/long bounding box values outfile (str) : File path to save downloaded raster SRTM_30 (bool) : If True, use SRTM 30m. If False, SRTM 90m. Returns tinerator.DEM instance from_shapefile from_shapefile ( shapefile , outfile = None , SRTM_30 = True ) Downloads and returns the DEM enclosed by a shapefile. This function is powered by the elevation package, and sources rasters from either SRTM 30m Global 1 arc second V003 elaborated by NASA and NGA, or SRTM 90m Digital Elevation Database v4.1 elaborated by CGIAR-CSI. Note: if this method fails with error 'Too many tiles', try again with SRTM_30=False . Arguments shapefile (str) : Path to ESRI Shapefile outfile (str) : File path to save downloaded raster SRTM_30 (bool) : If True, use SRTM 30m. If False, SRTM 90m. Returns tinerator.DEM instance","title":"load"},{"location":"api/load.html#tineratorload","text":"","title":"tinerator.load"},{"location":"api/load.html#from_file","text":"from_file ( filepath : str , lagrit_exe = None ) Loads a DEM raster from a local filepath and returns a tinerator.DEM instance. Arguments filepath (str) : Filepath to DEM raster","title":"from_file"},{"location":"api/load.html#from_matrix","text":"from_matrix ( array : numpy . ndarray , xllcorner = 0.0 , yllcorner = 0.0 , cell_size = 10.0 , no_data_value =- 9999 ) Creates a TINerator DEM instance from a Numpy 2D matrix. Arguments array (np.ndarray) : NxM Numpy matrix * xllcorner (int,float) : lower-left raster x-coordinate * yllcorner (int,float) : lower-left raster y-coordinate * cell_size (int,float) : raster cell size * no_data_value (int,float) : raster null value __ Note__: no_data_value cannot be np.nan. Returns tinerator.DEM instance","title":"from_matrix"},{"location":"api/load.html#from_coordinates","text":"from_coordinates ( bounding_box , outfile = None , SRTM_30 = True ) Downloads and returns a DEM from a geodetic coordinate bounding box. This function is powered by the elevation package, and sources rasters from either SRTM 30m Global 1 arc second V003 elaborated by NASA and NGA, or SRTM 90m Digital Elevation Database v4.1 elaborated by CGIAR-CSI. Note that note bounding box values must be latitude and longitude values given as: (left, bottom, right, top) . (Specifically, geodetic coordinates in the WGS84 reference system EPSG:4326.) Note: if this method fails with error 'Too many tiles', try again with SRTM_30=False . Arguments bounding_box (tuple) : Lat/long bounding box values outfile (str) : File path to save downloaded raster SRTM_30 (bool) : If True, use SRTM 30m. If False, SRTM 90m. Returns tinerator.DEM instance","title":"from_coordinates"},{"location":"api/load.html#from_shapefile","text":"from_shapefile ( shapefile , outfile = None , SRTM_30 = True ) Downloads and returns the DEM enclosed by a shapefile. This function is powered by the elevation package, and sources rasters from either SRTM 30m Global 1 arc second V003 elaborated by NASA and NGA, or SRTM 90m Digital Elevation Database v4.1 elaborated by CGIAR-CSI. Note: if this method fails with error 'Too many tiles', try again with SRTM_30=False . Arguments shapefile (str) : Path to ESRI Shapefile outfile (str) : File path to save downloaded raster SRTM_30 (bool) : If True, use SRTM 30m. If False, SRTM 90m. Returns tinerator.DEM instance","title":"from_shapefile"},{"location":"api/plot.html","text":"tinerator.plot plot_dem plot_dem ( dem_object , hillshade : bool = False , plot_out : str = None ) Plots the DEM corresponding to a tinerator.DEM object. Arguments dem_object (tinerator.DEM) : A DEM object to plot hillshade (bool) : use hillshading on plot plot_out (str) : filepath to save plot preview_accumulation preview_accumulation ( dem_object , method : str = 'D8' ) Preview the accumulation matrix on a DEM. Where this is useful is to preview the accumulation level at which you wish to capture a feature. Arguments dem_object (tinerator.DEM) : A DEM class instance method (str) : Flow calculation method at_threshold Returns The generated accumulation matrix plot_feature plot_feature ( dem_object ) Displays the feature captured by performing watershed delination Arguments dem_object (tinerator.DEM) : A DEM class instance plot_boundary plot_boundary ( dem_object ) Plots a tinerator.DEM boundary. Must have been created through the build_refined_triplane or build_uniform_triplane methods. Arguments dem_object (tinerator.DEM) : A DEM instance preview_boundary preview_boundary ( dem_object , distance : float , rectangular : bool = False , interactive = False ) Preview the mesh boundary nodes that will be generated by edge_length (in DEM.build_uniform_triplane ) or max_edge_length ( DEM.build_refined_triplane ). Arguments distance (float) : Euclidean distance between adjacent boundary nodes rectangular (bool) : if True, generates a boundary around the extent of the DEM interactive (bool) : if True and function is called within a Jupyter notebook, then function params can be controlled with sliders plot_faceset plot_faceset ( dem_object , faceset ) Displays a topological preview of how facesets will look after generation. Arguments dem_object (tinerator.DEM) : A DEM class instance faceset (tinerator.Faceset) : An initialized Faceset object plot_triplane plot_triplane ( dem_object ) Plots the triangular surface mesh. Arguments dem_object (tinerator.DEM) : A DEM class instance plot_full_mesh plot_full_mesh ( dem_object , facesets : list = None ) Plots the triangular surface mesh. Arguments dem_object (tinerator.DEM) : A DEM class instance facesets (list ) : facesets to render","title":"plot"},{"location":"api/plot.html#tineratorplot","text":"","title":"tinerator.plot"},{"location":"api/plot.html#plot_dem","text":"plot_dem ( dem_object , hillshade : bool = False , plot_out : str = None ) Plots the DEM corresponding to a tinerator.DEM object. Arguments dem_object (tinerator.DEM) : A DEM object to plot hillshade (bool) : use hillshading on plot plot_out (str) : filepath to save plot","title":"plot_dem"},{"location":"api/plot.html#preview_accumulation","text":"preview_accumulation ( dem_object , method : str = 'D8' ) Preview the accumulation matrix on a DEM. Where this is useful is to preview the accumulation level at which you wish to capture a feature. Arguments dem_object (tinerator.DEM) : A DEM class instance method (str) : Flow calculation method at_threshold Returns The generated accumulation matrix","title":"preview_accumulation"},{"location":"api/plot.html#plot_feature","text":"plot_feature ( dem_object ) Displays the feature captured by performing watershed delination Arguments dem_object (tinerator.DEM) : A DEM class instance","title":"plot_feature"},{"location":"api/plot.html#plot_boundary","text":"plot_boundary ( dem_object ) Plots a tinerator.DEM boundary. Must have been created through the build_refined_triplane or build_uniform_triplane methods. Arguments dem_object (tinerator.DEM) : A DEM instance","title":"plot_boundary"},{"location":"api/plot.html#preview_boundary","text":"preview_boundary ( dem_object , distance : float , rectangular : bool = False , interactive = False ) Preview the mesh boundary nodes that will be generated by edge_length (in DEM.build_uniform_triplane ) or max_edge_length ( DEM.build_refined_triplane ). Arguments distance (float) : Euclidean distance between adjacent boundary nodes rectangular (bool) : if True, generates a boundary around the extent of the DEM interactive (bool) : if True and function is called within a Jupyter notebook, then function params can be controlled with sliders","title":"preview_boundary"},{"location":"api/plot.html#plot_faceset","text":"plot_faceset ( dem_object , faceset ) Displays a topological preview of how facesets will look after generation. Arguments dem_object (tinerator.DEM) : A DEM class instance faceset (tinerator.Faceset) : An initialized Faceset object","title":"plot_faceset"},{"location":"api/plot.html#plot_triplane","text":"plot_triplane ( dem_object ) Plots the triangular surface mesh. Arguments dem_object (tinerator.DEM) : A DEM class instance","title":"plot_triplane"},{"location":"api/plot.html#plot_full_mesh","text":"plot_full_mesh ( dem_object , facesets : list = None ) Plots the triangular surface mesh. Arguments dem_object (tinerator.DEM) : A DEM class instance facesets (list ) : facesets to render","title":"plot_full_mesh"},{"location":"api/tinerator.html","text":"tinerator \u00a9 2019. Triad National Security, LLC. All rights reserved. This program was produced under U.S. Government contract 89233218CNA000001 for Los Alamos National Laboratory (LANL), which is operated by Triad National Security, LLC for the U.S. Department of Energy/National Nuclear Security Administration. All rights in the program are reserved by Triad National Security, LLC, and the U.S. Department of Energy/National Nuclear Security Administration. The Government is granted for itself and others acting on its behalf a nonexclusive, paid-up, irrevocable worldwide license in this material to reproduce, prepare derivative works, distribute copies to the public, perform publicly and display publicly, and to permit others to do so. reprojectShapefile reprojectShapefile ( shapefile : str , outfile : str , projection : str ) Re-projects a shapefile from one coordinate space to another. Arguments shapefile (str) : filepath to the shapefile outfile (str) : file to write re-projected shapefile to projection (str) : string with new projection; i.e. 'epsg:3413' maskRasterWithShapefile maskRasterWithShapefile ( raster_filename : str , shapefile_filename : str , shapefile_reprojection : str = None , raster_outfile : str = None , return_dem : bool = True ) Arguments raster_filename (str) : Raster file to be cropped shapefile_filename (str) : Shapefile to crop raster with Optional Arguments shapefile_reprojection (str): string with new projection; i.e. 'epsg:3413' raster_outfile (str): Filepath to save cropped raster return_dem (bool): if true, returns a tinerator.DEM object","title":"__init__"},{"location":"api/tinerator.html#tinerator","text":"\u00a9 2019. Triad National Security, LLC. All rights reserved. This program was produced under U.S. Government contract 89233218CNA000001 for Los Alamos National Laboratory (LANL), which is operated by Triad National Security, LLC for the U.S. Department of Energy/National Nuclear Security Administration. All rights in the program are reserved by Triad National Security, LLC, and the U.S. Department of Energy/National Nuclear Security Administration. The Government is granted for itself and others acting on its behalf a nonexclusive, paid-up, irrevocable worldwide license in this material to reproduce, prepare derivative works, distribute copies to the public, perform publicly and display publicly, and to permit others to do so.","title":"tinerator"},{"location":"api/tinerator.html#reprojectshapefile","text":"reprojectShapefile ( shapefile : str , outfile : str , projection : str ) Re-projects a shapefile from one coordinate space to another. Arguments shapefile (str) : filepath to the shapefile outfile (str) : file to write re-projected shapefile to projection (str) : string with new projection; i.e. 'epsg:3413'","title":"reprojectShapefile"},{"location":"api/tinerator.html#maskrasterwithshapefile","text":"maskRasterWithShapefile ( raster_filename : str , shapefile_filename : str , shapefile_reprojection : str = None , raster_outfile : str = None , return_dem : bool = True ) Arguments raster_filename (str) : Raster file to be cropped shapefile_filename (str) : Shapefile to crop raster with Optional Arguments shapefile_reprojection (str): string with new projection; i.e. 'epsg:3413' raster_outfile (str): Filepath to save cropped raster return_dem (bool): if true, returns a tinerator.DEM object","title":"maskRasterWithShapefile"},{"location":"api/util.html","text":"tinerator.utilities Set of functions that convert from matrix (row and column) units to a DEM projection, and vice versa. filter_points filter_points ( points : numpy . ndarray , eps : float ) Removes points that are within eps distance of each other. Arguments points (np.ndarray) : point array to filter eps (float) : remove adjacent points within this distance of each other Returns Filtered points","title":"util"},{"location":"api/util.html#tineratorutilities","text":"Set of functions that convert from matrix (row and column) units to a DEM projection, and vice versa.","title":"tinerator.utilities"},{"location":"api/util.html#filter_points","text":"filter_points ( points : numpy . ndarray , eps : float ) Removes points that are within eps distance of each other. Arguments points (np.ndarray) : point array to filter eps (float) : remove adjacent points within this distance of each other Returns Filtered points","title":"filter_points"},{"location":"tutorials/index.html","text":"Tutorial Importing DEMs and Shapefiles Overview on loading or downloading DEMs, basic GIS plotting and manipulation. Preparing the DEM Defining a mesh boundary and finding a stream network ('feature') through watershed delineation. Generating a Mesh Turning the DEM into a surface or volume mesh; uniform element density, or mesh refinement around a feature. Adding an Attribute Adding and manipulating cell and node attributes. Defining Facesets Defining subdomains of the mesh surfaces for setting solver boundary conditions.","title":"Index"},{"location":"tutorials/index.html#tutorial","text":"","title":"Tutorial"},{"location":"tutorials/index.html#importing-dems-and-shapefiles","text":"Overview on loading or downloading DEMs, basic GIS plotting and manipulation.","title":"Importing DEMs and Shapefiles"},{"location":"tutorials/index.html#preparing-the-dem","text":"Defining a mesh boundary and finding a stream network ('feature') through watershed delineation.","title":"Preparing the DEM"},{"location":"tutorials/index.html#generating-a-mesh","text":"Turning the DEM into a surface or volume mesh; uniform element density, or mesh refinement around a feature.","title":"Generating a Mesh"},{"location":"tutorials/index.html#adding-an-attribute","text":"Adding and manipulating cell and node attributes.","title":"Adding an Attribute"},{"location":"tutorials/index.html#defining-facesets","text":"Defining subdomains of the mesh surfaces for setting solver boundary conditions.","title":"Defining Facesets"},{"location":"tutorials/attributes.html","text":"Adding an Attribute Cell and node based attributes can be added to a stacked mesh - the attributes can be added either globally, across all layers, or local to one or more layers. Left: Soil map as read from an ASC file. Right: Soil map selectively applied to TIN layers. Reading and applying an attribute Basic syntax To add an attribute to a layered TIN, use the command: DEM . add_attribute ( data , layers = [], dtype = int ) where layers is a list containing all layers to apply the attribute to, and dtype is the desired attribute type ( int or float ). By default, the material will be applied to the mesh's material ID (or, 'cell color'). This can be changed with the name parameter. As an example, consider a stacked mesh with three layers and an arbitrary floating point attribute. To apply that attribute only to the second layer: my_dem . add_attribute ( data , layers = [ 2 ], dtype = float ) By default, layers = None . This applies the attribute raster to every layer of the mesh. Note Any number of attribute rasters can be applied to a mesh, as long as each is given a unique name. Attribute Format Attributes must fundamentally be an N\\times M N\\times M Numpy matrix. The dimensions of the matrix do not necessarily have to be the same as those of the DEM. The data argument of addAttribute must be of type np.ndarray . To import or convert from popular file formats, a table of functions is given below. Click the function name to be redirected to its documentation. Data type Import function GIS rasters ( .asc , .tif , ...) gdal.Open(file) Plain-text matrix ( .txt , .dat , ...) numpy.loadtxt(file) Python list np.array(list) HDF5 ( .h5 ) h5py.File(file,'r') Note that when attributes are applied in TINerator, their domain spans that of the parent DEM. In other words, it is assumed that the data matrix has the same lower-left and upper-right corners as the DEM it is being applied to. Considering Data Types As mesh nodes will not necessarily align within cell centers of attribute raster, interpolation on that raster is performed. Based on the argument dtype , interpolation onto the mesh nodes will either be continuous ( float ) or nearest-neighbor ( int ). This is critical for properties such as soil ID, which only hold value as defined integers. Applying a function Assume that an attribute has been applied across all layers of the mesh. In some situations, it may be beneficial to change the attribute values based on the layer ID. The below method maps a user-defined function and operator onto mesh data: tinerator . DEM . map_function_to_attribute ( self , operator = '+' , layers = None , attribute_name = None , outfile = None , fn = lambda layer : layer * 100 ) In other words, the new attribute data will be a result of: A_{i,j}(layer) = A_{i,j} \\: [operation] \\: f(layer) \\: \\forall \\: i,j A_{i,j}(layer) = A_{i,j} \\: [operation] \\: f(layer) \\: \\forall \\: i,j where A_{i,j} A_{i,j} is the attribute raster data at index i,j i,j . Example Assume that we have soil types with unique values [1,3,5,10,12...] , applied to all layers of some mesh. To better define, say, porosity as a function of layer in our simulation, we would like to prefix each value with the layer ID. In other words, changing layer 1: [1,3,5,10,12...] layer 2: [1,3,5,10,12...] layer 3: [1,3,5,10,12...] ... to layer 1: [101,103,105,110,112...] layer 2: [201,203,205,210,212...] layer 3: [301,103,305,310,312...] ... This can be accomplished by using the following function: A_{i,j}(layer) = A_{i,j} + 100 \\cdot layer \\: \\forall \\: i,j A_{i,j}(layer) = A_{i,j} + 100 \\cdot layer \\: \\forall \\: i,j That is, adding 100 \\cdot layer_{ID} 100 \\cdot layer_{ID} to every attribute data point. Consequently, we want the operator to be + + and f(layer) = 100 \\cdot layer f(layer) = 100 \\cdot layer , or, my_dem . map_function_to_attribute ( attribute_name = 'exampleAttribute' , operator = '+' , fn = lambda layer : layer * 100 )","title":"Adding an Attribute"},{"location":"tutorials/attributes.html#adding-an-attribute","text":"Cell and node based attributes can be added to a stacked mesh - the attributes can be added either globally, across all layers, or local to one or more layers. Left: Soil map as read from an ASC file. Right: Soil map selectively applied to TIN layers.","title":"Adding an Attribute"},{"location":"tutorials/attributes.html#reading-and-applying-an-attribute","text":"","title":"Reading and applying an attribute"},{"location":"tutorials/attributes.html#basic-syntax","text":"To add an attribute to a layered TIN, use the command: DEM . add_attribute ( data , layers = [], dtype = int ) where layers is a list containing all layers to apply the attribute to, and dtype is the desired attribute type ( int or float ). By default, the material will be applied to the mesh's material ID (or, 'cell color'). This can be changed with the name parameter. As an example, consider a stacked mesh with three layers and an arbitrary floating point attribute. To apply that attribute only to the second layer: my_dem . add_attribute ( data , layers = [ 2 ], dtype = float ) By default, layers = None . This applies the attribute raster to every layer of the mesh. Note Any number of attribute rasters can be applied to a mesh, as long as each is given a unique name.","title":"Basic syntax"},{"location":"tutorials/attributes.html#attribute-format","text":"Attributes must fundamentally be an N\\times M N\\times M Numpy matrix. The dimensions of the matrix do not necessarily have to be the same as those of the DEM. The data argument of addAttribute must be of type np.ndarray . To import or convert from popular file formats, a table of functions is given below. Click the function name to be redirected to its documentation. Data type Import function GIS rasters ( .asc , .tif , ...) gdal.Open(file) Plain-text matrix ( .txt , .dat , ...) numpy.loadtxt(file) Python list np.array(list) HDF5 ( .h5 ) h5py.File(file,'r') Note that when attributes are applied in TINerator, their domain spans that of the parent DEM. In other words, it is assumed that the data matrix has the same lower-left and upper-right corners as the DEM it is being applied to.","title":"Attribute Format"},{"location":"tutorials/attributes.html#considering-data-types","text":"As mesh nodes will not necessarily align within cell centers of attribute raster, interpolation on that raster is performed. Based on the argument dtype , interpolation onto the mesh nodes will either be continuous ( float ) or nearest-neighbor ( int ). This is critical for properties such as soil ID, which only hold value as defined integers.","title":"Considering Data Types"},{"location":"tutorials/attributes.html#applying-a-function","text":"Assume that an attribute has been applied across all layers of the mesh. In some situations, it may be beneficial to change the attribute values based on the layer ID. The below method maps a user-defined function and operator onto mesh data: tinerator . DEM . map_function_to_attribute ( self , operator = '+' , layers = None , attribute_name = None , outfile = None , fn = lambda layer : layer * 100 ) In other words, the new attribute data will be a result of: A_{i,j}(layer) = A_{i,j} \\: [operation] \\: f(layer) \\: \\forall \\: i,j A_{i,j}(layer) = A_{i,j} \\: [operation] \\: f(layer) \\: \\forall \\: i,j where A_{i,j} A_{i,j} is the attribute raster data at index i,j i,j .","title":"Applying a function"},{"location":"tutorials/attributes.html#example","text":"Assume that we have soil types with unique values [1,3,5,10,12...] , applied to all layers of some mesh. To better define, say, porosity as a function of layer in our simulation, we would like to prefix each value with the layer ID. In other words, changing layer 1: [1,3,5,10,12...] layer 2: [1,3,5,10,12...] layer 3: [1,3,5,10,12...] ... to layer 1: [101,103,105,110,112...] layer 2: [201,203,205,210,212...] layer 3: [301,103,305,310,312...] ... This can be accomplished by using the following function: A_{i,j}(layer) = A_{i,j} + 100 \\cdot layer \\: \\forall \\: i,j A_{i,j}(layer) = A_{i,j} + 100 \\cdot layer \\: \\forall \\: i,j That is, adding 100 \\cdot layer_{ID} 100 \\cdot layer_{ID} to every attribute data point. Consequently, we want the operator to be + + and f(layer) = 100 \\cdot layer f(layer) = 100 \\cdot layer , or, my_dem . map_function_to_attribute ( attribute_name = 'exampleAttribute' , operator = '+' , fn = lambda layer : layer * 100 )","title":"Example"},{"location":"tutorials/basics.html","text":"Importing DEMs and GIS data The DEM class structure After reading or downloading a DEM, an object of type tinerator.DEM is returned. This class contains all information related to tinning a particular GIS object: GIS data, such as the DEM matrix and shapefile polygons, meshing data, spatial data, and more. Further information on this class can be found by reading the API Documentation . The DEM - and associated metadata - is stored in the tinerator.DEM.dem attribute, which itself is a richdem.rdarray object: >>> print ( my_dem . dem . __dict__ ) { 'metadata' : { 'PROCESSING_HISTORY' : ' \\n 2019-01-23 18:53:20.598492 UTC | RichDEM (Python 0.3.4) (hash=\"ee05922\", hashdate=\"2018-07-13 13:01:09 -0700\") | LoadGDAL(filename=data/dem.asc, no_data=-9999.0)' }, 'no_data' : - 9999.0 , 'projection' : '' , 'geotransform' : ( 0.0 , 10.0 , 0.0 , 7510.0 , 0.0 , - 10.0 ) } Upon load, this metadata is parsed into specific tinerator.DEM variables. It is unlikely an end-user will need access to this RichDEM metadata. Reading DEMs Reading a DEM by file Reading a DEM via file is simply called by: import tinerator as tin my_dem = tin . load . from_file ( \"data/dem.asc\" ) The loading function uses GDAL as the I/O driver. Supported input filetypes can be found here . To verify import integrity, we can then plot the DEM and print metadata: my_dem . plot_dem () # Or, tin.plot.plot_dem(my_dem) print ( \"NODATAVALUE: {0} \\n Lower-left Corner: ({1},{2}) \\n Cell Size: {3}\" . format ( my_dem . no_data_value , my_dem . xll_corner , my_dem . yll_corner , my_dem . cell_size ) ) >>> NODATAVALUE: -9999.0 >>> Lower-left Corner: (0.0,0.0) >>> Cell Size: 10.0 Each of these metadata values are mutable and can be changed as circumstances dictate. Downloading from coordinates To download an SRTM 90m DEM by through a latitude / longitude bounding box, my_dem = tin . load . from_coordinates (( 12.35 , 41.8 , 12.65 , 42 ), outfile = 'Rome-90m-DEM.tif' ) where bounds is the bounding box values in geodetic coordinates (left, bottom, right, top), and outfile is an optional filepath to save the DEM. In this example, (12.35,41.8,12.65,42) represents a subsection of Rome: Downloading by Shapefile To download an SRTM 90m DEM through a Shapefile ( .shp ), my_dem = tin . load . from_shapefile ( \"shapefile.shp\" , crop = True ) The argument crop replaces all areas of the DEM not covered by the shapefile with a NoDataValue. Setting crop = False will only return a DEM bound by the spatial domain of the shapefile. With crop = True : With crop = False : Applying a Shapefile A DEM can be masked with a shapefile with the function tin.maskRasterWithShapefile . See the API for more information.","title":"Importing DEMs"},{"location":"tutorials/basics.html#importing-dems-and-gis-data","text":"","title":"Importing DEMs and GIS data"},{"location":"tutorials/basics.html#the-dem-class-structure","text":"After reading or downloading a DEM, an object of type tinerator.DEM is returned. This class contains all information related to tinning a particular GIS object: GIS data, such as the DEM matrix and shapefile polygons, meshing data, spatial data, and more. Further information on this class can be found by reading the API Documentation . The DEM - and associated metadata - is stored in the tinerator.DEM.dem attribute, which itself is a richdem.rdarray object: >>> print ( my_dem . dem . __dict__ ) { 'metadata' : { 'PROCESSING_HISTORY' : ' \\n 2019-01-23 18:53:20.598492 UTC | RichDEM (Python 0.3.4) (hash=\"ee05922\", hashdate=\"2018-07-13 13:01:09 -0700\") | LoadGDAL(filename=data/dem.asc, no_data=-9999.0)' }, 'no_data' : - 9999.0 , 'projection' : '' , 'geotransform' : ( 0.0 , 10.0 , 0.0 , 7510.0 , 0.0 , - 10.0 ) } Upon load, this metadata is parsed into specific tinerator.DEM variables. It is unlikely an end-user will need access to this RichDEM metadata.","title":"The DEM class structure"},{"location":"tutorials/basics.html#reading-dems","text":"","title":"Reading DEMs"},{"location":"tutorials/basics.html#reading-a-dem-by-file","text":"Reading a DEM via file is simply called by: import tinerator as tin my_dem = tin . load . from_file ( \"data/dem.asc\" ) The loading function uses GDAL as the I/O driver. Supported input filetypes can be found here . To verify import integrity, we can then plot the DEM and print metadata: my_dem . plot_dem () # Or, tin.plot.plot_dem(my_dem) print ( \"NODATAVALUE: {0} \\n Lower-left Corner: ({1},{2}) \\n Cell Size: {3}\" . format ( my_dem . no_data_value , my_dem . xll_corner , my_dem . yll_corner , my_dem . cell_size ) ) >>> NODATAVALUE: -9999.0 >>> Lower-left Corner: (0.0,0.0) >>> Cell Size: 10.0 Each of these metadata values are mutable and can be changed as circumstances dictate.","title":"Reading a DEM by file"},{"location":"tutorials/basics.html#downloading-from-coordinates","text":"To download an SRTM 90m DEM by through a latitude / longitude bounding box, my_dem = tin . load . from_coordinates (( 12.35 , 41.8 , 12.65 , 42 ), outfile = 'Rome-90m-DEM.tif' ) where bounds is the bounding box values in geodetic coordinates (left, bottom, right, top), and outfile is an optional filepath to save the DEM. In this example, (12.35,41.8,12.65,42) represents a subsection of Rome:","title":"Downloading from coordinates"},{"location":"tutorials/basics.html#downloading-by-shapefile","text":"To download an SRTM 90m DEM through a Shapefile ( .shp ), my_dem = tin . load . from_shapefile ( \"shapefile.shp\" , crop = True ) The argument crop replaces all areas of the DEM not covered by the shapefile with a NoDataValue. Setting crop = False will only return a DEM bound by the spatial domain of the shapefile. With crop = True : With crop = False :","title":"Downloading by Shapefile"},{"location":"tutorials/basics.html#applying-a-shapefile","text":"A DEM can be masked with a shapefile with the function tin.maskRasterWithShapefile . See the API for more information.","title":"Applying a Shapefile"},{"location":"tutorials/facesets.html","text":"Facesets Facesets are arbitrarily defined sections of the mesh's surface, which can be used in simulators such as ATS or Amanzi to define boundary conditions. A mesh using facesets is exported in the Exodus ( PDF ) format. Naive Facesets 'Naive' facesets are a collection of only three facesets: top, bottom, and sides. They can be generated with: sides_basic = tin . facesets . basic ( has_top = True , has_bottom = True , has_sides = True ) Complex Facesets In the above image, six distinct facesets are shown: Top layer Bottom layer Side (East) Side (West) Side (South) Outlet Note that the outlet faceset is localized entirely to the top layer. Faceset definitions such as these are unique to simulation parameters and goals. Consequently, they must be defined manually using one of two methods: Side selection via Coordinates If already you know the coordinates of the sidesets you wish to define, you can create an array defining starting/ending boundary nodes (in clockwise order ). Note that the coordinate space must be the same as the DEM. As an example, consider the following: ss_all_layers = np . array ([[ 3352.82 , 7284.46 ], [ 7936.85 , 4870.53 ], [ 1798.4 , 256.502 ], [ 1182.73 , 1030.19 ]]) ss_top_layer = np . array ([[ 780.41 , 304.79 ], [ 567.05 , 524.24 ]]) sides_all = tin . facesets . sidesets ( ss_all_layers ) sides_outlet = tin . facesets . sidesets ( ss_all_layers , top_layer = True ) Top surface selection Facesets can be generated using top-layer elevation discretization. Consider the heights array: heights = [ 50. , 100. , 150. , 200. ] Five top-surface facesets will be created: all surface elements lower than 50 meters all surface elements between 50 and 100 meters all surface elements between 100 and 150 meters all surface elements between 150 and 200 meters all surface elements greater than 200 meters Another approach is to split the elevation range into layers using properties min_z and max_z : >>> print ( 'Elevation range = ({0},{1})' . format ( dem . min_z , dem . max_z )) Elevation range = ( 2365.3 , 3942.2 ) >>> heights = np . linspace ( dem . min_z , dem . max_z , 10 ) >>> print ( heights ) array ([ 2365.3 , 2540.51111111 , 2715.72222222 , 2890.93333333 , 3066.14444444 , 3241.35555556 , 3416.56666667 , 3591.77777778 , 3766.98888889 , 3942.2 ]) To capture the faceset, call: faceset_top = tin . facesets . from_elevation ( heights ) Writing Mesh with Facesets To write an Exodus mesh with these facesets, call tin . dump . to_exodus ( my_dem , facesets = [ sides_all , sides_outlet , sides_basic ]) Any permutation of faceset objects is possible - just be aware that they may overlap if not constructed properly.","title":"Defining FaceSets"},{"location":"tutorials/facesets.html#facesets","text":"Facesets are arbitrarily defined sections of the mesh's surface, which can be used in simulators such as ATS or Amanzi to define boundary conditions. A mesh using facesets is exported in the Exodus ( PDF ) format.","title":"Facesets"},{"location":"tutorials/facesets.html#naive-facesets","text":"'Naive' facesets are a collection of only three facesets: top, bottom, and sides. They can be generated with: sides_basic = tin . facesets . basic ( has_top = True , has_bottom = True , has_sides = True )","title":"Naive Facesets"},{"location":"tutorials/facesets.html#complex-facesets","text":"In the above image, six distinct facesets are shown: Top layer Bottom layer Side (East) Side (West) Side (South) Outlet Note that the outlet faceset is localized entirely to the top layer. Faceset definitions such as these are unique to simulation parameters and goals. Consequently, they must be defined manually using one of two methods:","title":"Complex Facesets"},{"location":"tutorials/facesets.html#side-selection-via-coordinates","text":"If already you know the coordinates of the sidesets you wish to define, you can create an array defining starting/ending boundary nodes (in clockwise order ). Note that the coordinate space must be the same as the DEM. As an example, consider the following: ss_all_layers = np . array ([[ 3352.82 , 7284.46 ], [ 7936.85 , 4870.53 ], [ 1798.4 , 256.502 ], [ 1182.73 , 1030.19 ]]) ss_top_layer = np . array ([[ 780.41 , 304.79 ], [ 567.05 , 524.24 ]]) sides_all = tin . facesets . sidesets ( ss_all_layers ) sides_outlet = tin . facesets . sidesets ( ss_all_layers , top_layer = True )","title":"Side selection via Coordinates"},{"location":"tutorials/facesets.html#top-surface-selection","text":"Facesets can be generated using top-layer elevation discretization. Consider the heights array: heights = [ 50. , 100. , 150. , 200. ] Five top-surface facesets will be created: all surface elements lower than 50 meters all surface elements between 50 and 100 meters all surface elements between 100 and 150 meters all surface elements between 150 and 200 meters all surface elements greater than 200 meters Another approach is to split the elevation range into layers using properties min_z and max_z : >>> print ( 'Elevation range = ({0},{1})' . format ( dem . min_z , dem . max_z )) Elevation range = ( 2365.3 , 3942.2 ) >>> heights = np . linspace ( dem . min_z , dem . max_z , 10 ) >>> print ( heights ) array ([ 2365.3 , 2540.51111111 , 2715.72222222 , 2890.93333333 , 3066.14444444 , 3241.35555556 , 3416.56666667 , 3591.77777778 , 3766.98888889 , 3942.2 ]) To capture the faceset, call: faceset_top = tin . facesets . from_elevation ( heights )","title":"Top surface selection"},{"location":"tutorials/facesets.html#writing-mesh-with-facesets","text":"To write an Exodus mesh with these facesets, call tin . dump . to_exodus ( my_dem , facesets = [ sides_all , sides_outlet , sides_basic ]) Any permutation of faceset objects is possible - just be aware that they may overlap if not constructed properly.","title":"Writing Mesh with Facesets"},{"location":"tutorials/meshing.html","text":"Mesh Generation At this point, the DEM should be sufficiently post-processed, and we can begin the process of constructing a TIN. TIN generation is done in several discrete steps: Triplane (surface) generation Applying elevation to surface Extruding into defined layers Applying materials to layers Steps 1+2 and steps 3+4 are controlled with the following methods, respectively: DEM . build_refined_triplane ( ** kwargs ) # Steps 1 & 2 DEM . build_layered_mesh ( ** kwargs ) # Steps 3 & 4 Details on using these methods will be explained in the subsections below; for more information, read the method documentation . Building a Surface Mesh By default, TINerator will automatically determine whether to contruct a surface with refined or uniform triangles. If watershed delineation has not been performed, or the class variable DEM.feature = None , then TINerator will generate a uniform surface. Otherwise, it will be refined. The generated surface mesh will maintain the same spatial domain as the parent DEM. This may cause overflow errors if the DEM domain is close to or exceeds the limit of a double-precision float. Uniform Once the boundary is generated, calculating a triplane is as simple as: my_dem . build_uniform_triplane ( edge_length ) By default, DEM elevation data will be continuously interpolated onto the Z-values of the surface triangles. A completely flat mesh can be constructed instead with the method argument apply_elevation = False . Refined For generating a refined surface, call the method: my_dem . build_refined_triplane ( min_edge , max_edge ) where min_edge will be the shortest edge generated in the refining process, and max_edge will be the longest. This method works by (i) coarsely triangulating the interior of the boundary, and (ii) adaptively refining triangles according to a gradient field. The gradient field is a raster with values that scale relative to the Euclidean distance from the feature. Triangle edge length scales linearly from min_edge , where the gradient field is 0 (at the feature), towards max_edge , where the gradient field is 1 (at the edge of the DEM domain), according to this equation: e(i,j) = e_{min} + \\left( e_{max} - e_{min} \\right) \\cdot \\nabla D(i,j) e(i,j) = e_{min} + \\left( e_{max} - e_{min} \\right) \\cdot \\nabla D(i,j) As stated above, DEM elevation data will be interpolated onto the Z-coordinate of the surface nodes unless explicitly defined otherwise. Mesh Quality Triangulation is done with a Delaunay triangulation algorithm, and the mesh is iteratively smoothed with Laplacian smoothing . The number of smoothing / reconnection iterations can be controlled with the keyword iterations : int . Mesh quality can be found through the method: DEM . quality ( 'surface' ) This returns a dictionary containing aspect ratio statistics ( \\theta_{max} / \\theta_{min} \\theta_{max} / \\theta_{min} ), edge length ratio statistics ( e_{max} / e_{min} e_{max} / e_{min} ), and count of malformed elements (triangles with very large angles, very small angles, or very small areas). Stacking the Mesh Mesh extrusion is the process of extruding a triangular surface mesh into a volumetric prism mesh. This method is called using tinerator . DEM . layeredMesh ( ** kwargs ) For more information, see the documentation . As an example, after generating a triangular surface mesh, it can be layered by: layers = [ 0.1 , 0.3 , 0.6 , 8. , 21. ] # Define layer thickness matids = [ 1 , 2 , 3 , 4 , 5 ] # Define material ID my_dem . build_layered_mesh ( layers , matids = matids ) where layers is a list of length N , containing the sequential depths of layers to extrude, and matids is a list of length N containing the sequential integer IDs for each layer. For example, layer 1 will have a depth of 0.1 meters and a material ID of 1, layer 2 will have a depth of 0.3 and a material ID of 2, and so on. Note The length of list layers must equal the length of list matids Layers Depending on your particular use case, you may want as few as one layer, or many more. Layers may be of any arbitrary thickness, with units the same as the DEM parent. Note that the number of elements in the volumetric mesh, N_{volume} N_{volume} , is directly proportional to the number of layers n_{layers} n_{layers} : N_{volume} = N_{surface} \\cdot n_{layers} N_{volume} = N_{surface} \\cdot n_{layers} Five-layer prism mesh. Layer depths have been strongly exaggerated for effect. Materials Each layer can optionally have its own material ID - this provides an easy way to identify which layer an element is in, or to find elements within a defined layer. Note that material ID is not necessarily an attribute - it is a non-zero integer value mapped to an element. Cell and node based attributes are applied using a different process - read more here . An exaggerated view of layers colored by material ID. Note that some values are unique to its layer, while other layers share an ID.","title":"Generating a Mesh"},{"location":"tutorials/meshing.html#mesh-generation","text":"At this point, the DEM should be sufficiently post-processed, and we can begin the process of constructing a TIN. TIN generation is done in several discrete steps: Triplane (surface) generation Applying elevation to surface Extruding into defined layers Applying materials to layers Steps 1+2 and steps 3+4 are controlled with the following methods, respectively: DEM . build_refined_triplane ( ** kwargs ) # Steps 1 & 2 DEM . build_layered_mesh ( ** kwargs ) # Steps 3 & 4 Details on using these methods will be explained in the subsections below; for more information, read the method documentation .","title":"Mesh Generation"},{"location":"tutorials/meshing.html#building-a-surface-mesh","text":"By default, TINerator will automatically determine whether to contruct a surface with refined or uniform triangles. If watershed delineation has not been performed, or the class variable DEM.feature = None , then TINerator will generate a uniform surface. Otherwise, it will be refined. The generated surface mesh will maintain the same spatial domain as the parent DEM. This may cause overflow errors if the DEM domain is close to or exceeds the limit of a double-precision float.","title":"Building a Surface Mesh"},{"location":"tutorials/meshing.html#uniform","text":"Once the boundary is generated, calculating a triplane is as simple as: my_dem . build_uniform_triplane ( edge_length ) By default, DEM elevation data will be continuously interpolated onto the Z-values of the surface triangles. A completely flat mesh can be constructed instead with the method argument apply_elevation = False .","title":"Uniform"},{"location":"tutorials/meshing.html#refined","text":"For generating a refined surface, call the method: my_dem . build_refined_triplane ( min_edge , max_edge ) where min_edge will be the shortest edge generated in the refining process, and max_edge will be the longest. This method works by (i) coarsely triangulating the interior of the boundary, and (ii) adaptively refining triangles according to a gradient field. The gradient field is a raster with values that scale relative to the Euclidean distance from the feature. Triangle edge length scales linearly from min_edge , where the gradient field is 0 (at the feature), towards max_edge , where the gradient field is 1 (at the edge of the DEM domain), according to this equation: e(i,j) = e_{min} + \\left( e_{max} - e_{min} \\right) \\cdot \\nabla D(i,j) e(i,j) = e_{min} + \\left( e_{max} - e_{min} \\right) \\cdot \\nabla D(i,j) As stated above, DEM elevation data will be interpolated onto the Z-coordinate of the surface nodes unless explicitly defined otherwise.","title":"Refined"},{"location":"tutorials/meshing.html#mesh-quality","text":"Triangulation is done with a Delaunay triangulation algorithm, and the mesh is iteratively smoothed with Laplacian smoothing . The number of smoothing / reconnection iterations can be controlled with the keyword iterations : int . Mesh quality can be found through the method: DEM . quality ( 'surface' ) This returns a dictionary containing aspect ratio statistics ( \\theta_{max} / \\theta_{min} \\theta_{max} / \\theta_{min} ), edge length ratio statistics ( e_{max} / e_{min} e_{max} / e_{min} ), and count of malformed elements (triangles with very large angles, very small angles, or very small areas).","title":"Mesh Quality"},{"location":"tutorials/meshing.html#stacking-the-mesh","text":"Mesh extrusion is the process of extruding a triangular surface mesh into a volumetric prism mesh. This method is called using tinerator . DEM . layeredMesh ( ** kwargs ) For more information, see the documentation . As an example, after generating a triangular surface mesh, it can be layered by: layers = [ 0.1 , 0.3 , 0.6 , 8. , 21. ] # Define layer thickness matids = [ 1 , 2 , 3 , 4 , 5 ] # Define material ID my_dem . build_layered_mesh ( layers , matids = matids ) where layers is a list of length N , containing the sequential depths of layers to extrude, and matids is a list of length N containing the sequential integer IDs for each layer. For example, layer 1 will have a depth of 0.1 meters and a material ID of 1, layer 2 will have a depth of 0.3 and a material ID of 2, and so on. Note The length of list layers must equal the length of list matids","title":"Stacking the Mesh"},{"location":"tutorials/meshing.html#layers","text":"Depending on your particular use case, you may want as few as one layer, or many more. Layers may be of any arbitrary thickness, with units the same as the DEM parent. Note that the number of elements in the volumetric mesh, N_{volume} N_{volume} , is directly proportional to the number of layers n_{layers} n_{layers} : N_{volume} = N_{surface} \\cdot n_{layers} N_{volume} = N_{surface} \\cdot n_{layers} Five-layer prism mesh. Layer depths have been strongly exaggerated for effect.","title":"Layers"},{"location":"tutorials/meshing.html#materials","text":"Each layer can optionally have its own material ID - this provides an easy way to identify which layer an element is in, or to find elements within a defined layer. Note that material ID is not necessarily an attribute - it is a non-zero integer value mapped to an element. Cell and node based attributes are applied using a different process - read more here . An exaggerated view of layers colored by material ID. Note that some values are unique to its layer, while other layers share an ID.","title":"Materials"},{"location":"tutorials/watershed.html","text":"Preparing the DEM One of the most powerful features of TINerator is the ability to create meshes which are variably refined around some DEM feature, such as a river or stream network. To prepare the DEM for mesh generation, a feature needs to be (optionally) defined, and a boundary generated. Note that an option in TINerator exists to generate a mesh without feature refinement - see the mesh generation section for more information. Watershed Delineation Defining a river or stream network ('feature') in the DEM is done through the command: my_dem . watershed_delineation ( 4500. ) Performing a watershed delineation is a multi-step process: Depressions ('pits') are filled Flats are resolved Flow accumulation is performed Resolving Depressions and Flats Source: Lindsay, John. (2015). Efficient hybrid breaching-filling sink removal methods for flow path enforcement in digital elevation models. Hydrological Processes. 30. 846\u2013857. doi: 10.1002/hyp.10648 . Flow accumulation algorithms are numerous , but they all tend to operate relative to elevation deltas between adjacent DEM cells. Consequently, flats and pits can disrupt accumulation algorithms, causing premature termination of the flow patterns. It is therefore, in general, best to preprocess a DEM to remove depressions and flats. Depressions and flats identified and removed on a standard DEM Flat and pit resolution is the default behavior of the watershedDelineation function. For more information on better controlling these steps, refer to the API Documentation . The DEM feature will be found in the class variable tinerator.DEM.feature , and is an N-by-2 np.ndarray defining a polyline. Flow accumulation A critical step in determining river networks is through flow accumulation algorithms. These algorithms generate a raster of accumulated flow by accumulating the weight of all cells that flow into adjacent cells with a negative elevation data ('downslope cells'). Source: ArcGis Pro, How Flow Accumulation works TINerator supports a number of popular flow accumulation algorithms: D8 D4 D-Infinity Rho8 Rho4 Quinn Freeman Holmgren By default, D8 is used. For more information on these different algorithms, visit the RichDEM Flow Metrics page . After flow accumulation is performed, the feature can be extracted by setting an accumulation threshold and defining all cells above that threshold to be a part of the feature. As an example, see the below figure: Left: Flow accumulation intensity. Right: Feature pulled by thresholding the flow accumulation matrix. On the left, the raster generated by the flow accumulation algorithm is displayed. Note that effectively all non-masked cells in the DEM have some non-zero amount of accumulation. By settings threshold = 0. , effectively the entire DEM would be 'captured' as a feature. Note that, if you only consider cells with more than 10^4 10^4 accumulations, a river network becomes visible. Consequently, the threshold should be set to reflect that. Here, threshold = 4.5E10 , and the feature derived from setting that threshold value is shown on the right of the figure. Note The optimal threshold value will change for each distinct DEM. Pay careful attention to set a value relative to your workflow goals. Boundary Generation Boundary generation is done using a Square Tracing Algorithm to quickly capture the perimeter of the DEM. The boundary is defined as the interface between cells with NoDataValue entries ( z_{i,j} = NDV z_{i,j} = NDV ) and cells with data ( z_{i,j} \\ne NDV z_{i,j} \\ne NDV ). For DEMs that do not have cells with NoDataValue elements ( z(i,j) \\cap NDV = \\emptyset z(i,j) \\cap NDV = \\emptyset ), a rectangular boundary spanning the domain of the DEM is generated instead. The boundary is generated automatically on DEM.build_refined_triplane or DEM.build_uniform_triplane . This boundary can be previewed using tin . plot . preview_boundary ( my_dem )","title":"Preparing the DEM"},{"location":"tutorials/watershed.html#preparing-the-dem","text":"One of the most powerful features of TINerator is the ability to create meshes which are variably refined around some DEM feature, such as a river or stream network. To prepare the DEM for mesh generation, a feature needs to be (optionally) defined, and a boundary generated. Note that an option in TINerator exists to generate a mesh without feature refinement - see the mesh generation section for more information.","title":"Preparing the DEM"},{"location":"tutorials/watershed.html#watershed-delineation","text":"Defining a river or stream network ('feature') in the DEM is done through the command: my_dem . watershed_delineation ( 4500. ) Performing a watershed delineation is a multi-step process: Depressions ('pits') are filled Flats are resolved Flow accumulation is performed","title":"Watershed Delineation"},{"location":"tutorials/watershed.html#resolving-depressions-and-flats","text":"Source: Lindsay, John. (2015). Efficient hybrid breaching-filling sink removal methods for flow path enforcement in digital elevation models. Hydrological Processes. 30. 846\u2013857. doi: 10.1002/hyp.10648 . Flow accumulation algorithms are numerous , but they all tend to operate relative to elevation deltas between adjacent DEM cells. Consequently, flats and pits can disrupt accumulation algorithms, causing premature termination of the flow patterns. It is therefore, in general, best to preprocess a DEM to remove depressions and flats. Depressions and flats identified and removed on a standard DEM Flat and pit resolution is the default behavior of the watershedDelineation function. For more information on better controlling these steps, refer to the API Documentation . The DEM feature will be found in the class variable tinerator.DEM.feature , and is an N-by-2 np.ndarray defining a polyline.","title":"Resolving Depressions and Flats"},{"location":"tutorials/watershed.html#flow-accumulation","text":"A critical step in determining river networks is through flow accumulation algorithms. These algorithms generate a raster of accumulated flow by accumulating the weight of all cells that flow into adjacent cells with a negative elevation data ('downslope cells'). Source: ArcGis Pro, How Flow Accumulation works TINerator supports a number of popular flow accumulation algorithms: D8 D4 D-Infinity Rho8 Rho4 Quinn Freeman Holmgren By default, D8 is used. For more information on these different algorithms, visit the RichDEM Flow Metrics page . After flow accumulation is performed, the feature can be extracted by setting an accumulation threshold and defining all cells above that threshold to be a part of the feature. As an example, see the below figure: Left: Flow accumulation intensity. Right: Feature pulled by thresholding the flow accumulation matrix. On the left, the raster generated by the flow accumulation algorithm is displayed. Note that effectively all non-masked cells in the DEM have some non-zero amount of accumulation. By settings threshold = 0. , effectively the entire DEM would be 'captured' as a feature. Note that, if you only consider cells with more than 10^4 10^4 accumulations, a river network becomes visible. Consequently, the threshold should be set to reflect that. Here, threshold = 4.5E10 , and the feature derived from setting that threshold value is shown on the right of the figure. Note The optimal threshold value will change for each distinct DEM. Pay careful attention to set a value relative to your workflow goals.","title":"Flow accumulation"},{"location":"tutorials/watershed.html#boundary-generation","text":"Boundary generation is done using a Square Tracing Algorithm to quickly capture the perimeter of the DEM. The boundary is defined as the interface between cells with NoDataValue entries ( z_{i,j} = NDV z_{i,j} = NDV ) and cells with data ( z_{i,j} \\ne NDV z_{i,j} \\ne NDV ). For DEMs that do not have cells with NoDataValue elements ( z(i,j) \\cap NDV = \\emptyset z(i,j) \\cap NDV = \\emptyset ), a rectangular boundary spanning the domain of the DEM is generated instead. The boundary is generated automatically on DEM.build_refined_triplane or DEM.build_uniform_triplane . This boundary can be previewed using tin . plot . preview_boundary ( my_dem )","title":"Boundary Generation"}]}