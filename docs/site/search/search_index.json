{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to TINerator Introduction TINerator is a tool for the fast creation of extruded meshes from DEM and GIS data, developed at Los Alamos National Laboratory to aid in hydrogeological simulations. TINerator allows a user to define a bounding box of latitude/longitude coordinates, a shapefile, or a local DEM, and generate a triplane or extruded mesh. The mesh will have the topology of the DEM, along with user-defined material IDs and depths for stacked layers. Further, TINerator performs watershed delination on the defined DEM and refines the mesh\u2019s elements around the feature to a user-defined length scale. TINerator comes with a host of 2D and 3D visualization functions, allowing the user to view the status of the mesh at every step in the workflow. In addition, there are geometrical tools for removing triangles outside of a polygon, generating quality analytics on the mesh, adding cell- and node-based attributes to a mesh, and much more. Under Construction This page is under active construction. Visit Installation and Tutorials to get started.","title":"Introduction"},{"location":"#welcome-to-tinerator","text":"","title":"Welcome to TINerator"},{"location":"#introduction","text":"TINerator is a tool for the fast creation of extruded meshes from DEM and GIS data, developed at Los Alamos National Laboratory to aid in hydrogeological simulations. TINerator allows a user to define a bounding box of latitude/longitude coordinates, a shapefile, or a local DEM, and generate a triplane or extruded mesh. The mesh will have the topology of the DEM, along with user-defined material IDs and depths for stacked layers. Further, TINerator performs watershed delination on the defined DEM and refines the mesh\u2019s elements around the feature to a user-defined length scale. TINerator comes with a host of 2D and 3D visualization functions, allowing the user to view the status of the mesh at every step in the workflow. In addition, there are geometrical tools for removing triangles outside of a polygon, generating quality analytics on the mesh, adding cell- and node-based attributes to a mesh, and much more.","title":"Introduction"},{"location":"#under-construction","text":"This page is under active construction. Visit Installation and Tutorials to get started.","title":"Under Construction"},{"location":"about/","text":"About TINerator Funding TINerator is a collaborative effort between Los Alamos National Laboratory and Lawrence Berkeley National Laboratory. Development of TINerator is sponsored in part by XXXX and YYYYY. Development Team Daniel Livingston (EES-16; Los Alamos National Laboratory) David Moulton (EES-14; Los Alamos National Laboratory) Ilhan Ozgen (CESD; Lawrence Berkeley National Laboratory) Zexuan Xu (CESD; Lawrence Berkeley National Laboratory) Richard Middleton (EES-16; Los Alamos National Laboratory) Terry Miller (EES-16; Los Alamos National Laboratory) Carl Gable (EES-16; Los Alamos National Laboratory) Contact Contact livingston@lanl.gov with questions and issues. License TINerator is licensed under the BSD-3 license. Click here to visit the license page .","title":"About"},{"location":"about/#about-tinerator","text":"","title":"About TINerator"},{"location":"about/#funding","text":"TINerator is a collaborative effort between Los Alamos National Laboratory and Lawrence Berkeley National Laboratory. Development of TINerator is sponsored in part by XXXX and YYYYY.","title":"Funding"},{"location":"about/#development-team","text":"Daniel Livingston (EES-16; Los Alamos National Laboratory) David Moulton (EES-14; Los Alamos National Laboratory) Ilhan Ozgen (CESD; Lawrence Berkeley National Laboratory) Zexuan Xu (CESD; Lawrence Berkeley National Laboratory) Richard Middleton (EES-16; Los Alamos National Laboratory) Terry Miller (EES-16; Los Alamos National Laboratory) Carl Gable (EES-16; Los Alamos National Laboratory)","title":"Development Team"},{"location":"about/#contact","text":"Contact livingston@lanl.gov with questions and issues.","title":"Contact"},{"location":"about/#license","text":"TINerator is licensed under the BSD-3 license. Click here to visit the license page .","title":"License"},{"location":"contributing/","text":"Contributing How to Contribute Contribution Requirements Pull requests for missing features, bug fixes, and documentation updates are more than welcome. To contribute, please submit a pull request at https://github.com/lanl/LaGriT To ensure the best chance of acceptance for your pull request, please ensure that: All tests pass Your code is well documented and commented If adding new functionality, that unit tests have been included in the PR That the purpose and scope of your contributions are well explained in the PR Need an Issue? Visit the Issues page of LaGriT and search for tag 'Good First Issue'. These are great issues for someone unfamiliar with the codebase to work on. Contributor License Agreement (CLA) If you are an external (non-LANL or LBNL) contributor, then in order to accept your pull request, we need you to submit a CLA. This license is for your protection as a Contributor as well as the protection of LANL and LaGriT users; it does not change your rights to use your own Contributions for any other purpose. Sign the CLA here: https://www.clahub.com/agreements/lanl/LaGriT License By contributing to TINerator, you agree that your contributions will be licensed under the BSD-3 license.","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#how-to-contribute","text":"","title":"How to Contribute"},{"location":"contributing/#contribution-requirements","text":"Pull requests for missing features, bug fixes, and documentation updates are more than welcome. To contribute, please submit a pull request at https://github.com/lanl/LaGriT To ensure the best chance of acceptance for your pull request, please ensure that: All tests pass Your code is well documented and commented If adding new functionality, that unit tests have been included in the PR That the purpose and scope of your contributions are well explained in the PR","title":"Contribution Requirements"},{"location":"contributing/#need-an-issue","text":"Visit the Issues page of LaGriT and search for tag 'Good First Issue'. These are great issues for someone unfamiliar with the codebase to work on.","title":"Need an Issue?"},{"location":"contributing/#contributor-license-agreement-cla","text":"If you are an external (non-LANL or LBNL) contributor, then in order to accept your pull request, we need you to submit a CLA. This license is for your protection as a Contributor as well as the protection of LANL and LaGriT users; it does not change your rights to use your own Contributions for any other purpose. Sign the CLA here: https://www.clahub.com/agreements/lanl/LaGriT","title":"Contributor License Agreement (CLA)"},{"location":"contributing/#license","text":"By contributing to TINerator, you agree that your contributions will be licensed under the BSD-3 license.","title":"License"},{"location":"install/","text":"Installation While TINerator is a relatively light module, it depends on several compiled libraries and packages. Consequently, it is recommended that you set up a Conda environment or virtual-env for managing TINerator: $ conda create --name tinerator python = 3 .5 $ source activate tinerator Note that you will have to re-run the source activate command on each new shell instance. Python Requirements TINerator requires Python 3.4+ and the following Python modules: Module URL RichDEM https://richdem.readthedocs.io Matplotlib https://matplotlib.org Numpy http://www.numpy.org SciPy https://www.scipy.org Rasterio https://rasterio.readthedocs.io Fiona https://fiona.readthedocs.io Elevation http://elevation.bopen.eu/en/stable/ PyLaGriT https://lanl.github.io/LaGriT/pylagrit/original/index.html With the exception of PyLaGriT, all modules will be automatically installed when running the python setup.py install command in TINerator. Warning On macOS, the default clang C/C++ compilers seem to fail on compilation of richdem . To circumvent this, export CC; export CXX to GNU GCC compilers. Building LaGriT + Exodus LaGriT is a mesh generation software suite built by Los Alamos National Laboratories, and it (wrapped by the Python library PyLaGriT) is the 'engine' driving TINerator. A LaGriT binary needs to be present on your system before proceeding. You can directly download a pre-built binary, or to build one yourself, run: git clone https://github.com/lanl/LaGriT.git && cd LaGriT make exodus make static && make test You will find the LaGriT executable in $( LAGRIT_ROOT_DIR ) /src/lagrit . For more information, please see the LaGriT installation documentation . Warning LaGriT does not currently support Windows compilation. Windows support is coming soon. Installing PyLaGriT PyLaGriT is a subfolder within the LaGriT repo. Navigate to $( LAGRIT_ROOT_DIR ) /PyLaGriT and run python setup.py install Next, create the file ~/.pylagritrc with the following text: lagrit_exe : 'path/to/lagrit/executable' where path/to/lagrit/executable is the path to the recently downloaded/installed LaGriT binary. For more information, visit the PyLaGriT installation page . Installing TINerator TINerator is currently a submodule within a branch on the LaGriT repository. Navigate to $( LAGRIT_ROOT_DIR ) and run git checkout tinerator cd tinerator python setup.py install TINerator should now be installed and ready for use. If you experience any difficulty building TINerator, please open an issue on the LaGriT Issues page . Next Steps Check out Examples to get started, or read the API for function and method documentation.","title":"Installation"},{"location":"install/#installation","text":"While TINerator is a relatively light module, it depends on several compiled libraries and packages. Consequently, it is recommended that you set up a Conda environment or virtual-env for managing TINerator: $ conda create --name tinerator python = 3 .5 $ source activate tinerator Note that you will have to re-run the source activate command on each new shell instance.","title":"Installation"},{"location":"install/#python-requirements","text":"TINerator requires Python 3.4+ and the following Python modules: Module URL RichDEM https://richdem.readthedocs.io Matplotlib https://matplotlib.org Numpy http://www.numpy.org SciPy https://www.scipy.org Rasterio https://rasterio.readthedocs.io Fiona https://fiona.readthedocs.io Elevation http://elevation.bopen.eu/en/stable/ PyLaGriT https://lanl.github.io/LaGriT/pylagrit/original/index.html With the exception of PyLaGriT, all modules will be automatically installed when running the python setup.py install command in TINerator. Warning On macOS, the default clang C/C++ compilers seem to fail on compilation of richdem . To circumvent this, export CC; export CXX to GNU GCC compilers.","title":"Python Requirements"},{"location":"install/#building-lagrit-exodus","text":"LaGriT is a mesh generation software suite built by Los Alamos National Laboratories, and it (wrapped by the Python library PyLaGriT) is the 'engine' driving TINerator. A LaGriT binary needs to be present on your system before proceeding. You can directly download a pre-built binary, or to build one yourself, run: git clone https://github.com/lanl/LaGriT.git && cd LaGriT make exodus make static && make test You will find the LaGriT executable in $( LAGRIT_ROOT_DIR ) /src/lagrit . For more information, please see the LaGriT installation documentation . Warning LaGriT does not currently support Windows compilation. Windows support is coming soon.","title":"Building LaGriT + Exodus"},{"location":"install/#installing-pylagrit","text":"PyLaGriT is a subfolder within the LaGriT repo. Navigate to $( LAGRIT_ROOT_DIR ) /PyLaGriT and run python setup.py install Next, create the file ~/.pylagritrc with the following text: lagrit_exe : 'path/to/lagrit/executable' where path/to/lagrit/executable is the path to the recently downloaded/installed LaGriT binary. For more information, visit the PyLaGriT installation page .","title":"Installing PyLaGriT"},{"location":"install/#installing-tinerator","text":"TINerator is currently a submodule within a branch on the LaGriT repository. Navigate to $( LAGRIT_ROOT_DIR ) and run git checkout tinerator cd tinerator python setup.py install TINerator should now be installed and ready for use. If you experience any difficulty building TINerator, please open an issue on the LaGriT Issues page .","title":"Installing TINerator"},{"location":"install/#next-steps","text":"Check out Examples to get started, or read the API for function and method documentation.","title":"Next Steps"},{"location":"license/","text":"License (BSD) Copyright \u00a9 2016, Los Alamos National Security. LLC All rights reserved. Copyright 2016. Los Alamos National Security, LLC. This software was produced under U.S. Government contract DE-AC52-06NA25396 for Los Alamos National Laboratory (LANL), which is operated by Los Alamos National Security, LLC for the U.S. Department of Energy. The U.S. Government has rights to use, reproduce, and distribute this software. NEITHER THE GOVERNMENT NOR LOS ALAMOS NATIONAL SECURITY, LLC MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LIABILITY FOR THE USE OF THIS SOFTWARE. If software is modified to produce derivative works, such modified software should be clearly marked, so as not to confuse it with the version available from LANL. Additionally, redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of Los Alamos National Security, LLC, Los Alamos National Laboratory, LANL, the U.S. Government, nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY LOS ALAMOS NATIONAL SECURITY, LLC AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL LOS ALAMOS NATIONAL SECURITY, LLC OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"license/#license-bsd","text":"Copyright \u00a9 2016, Los Alamos National Security. LLC All rights reserved. Copyright 2016. Los Alamos National Security, LLC. This software was produced under U.S. Government contract DE-AC52-06NA25396 for Los Alamos National Laboratory (LANL), which is operated by Los Alamos National Security, LLC for the U.S. Department of Energy. The U.S. Government has rights to use, reproduce, and distribute this software. NEITHER THE GOVERNMENT NOR LOS ALAMOS NATIONAL SECURITY, LLC MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LIABILITY FOR THE USE OF THIS SOFTWARE. If software is modified to produce derivative works, such modified software should be clearly marked, so as not to confuse it with the version available from LANL. Additionally, redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of Los Alamos National Security, LLC, Los Alamos National Laboratory, LANL, the U.S. Government, nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY LOS ALAMOS NATIONAL SECURITY, LLC AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL LOS ALAMOS NATIONAL SECURITY, LLC OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License (BSD)"},{"location":"release_notes/","text":"Release Notes 0.3.0 (01/25/19) - Massive documentation updates 0.2.0 (DATE) - Full change from LaGriT infiles to PyLaGriT syntax 0.1.1 (08/12/18) - Minor bug fixes and beginning of documentation. 0.1.0 (08/10/18) - Initial release.","title":"Release Notes"},{"location":"release_notes/#release-notes","text":"0.3.0 (01/25/19) - Massive documentation updates 0.2.0 (DATE) - Full change from LaGriT infiles to PyLaGriT syntax 0.1.1 (08/12/18) - Minor bug fixes and beginning of documentation. 0.1.0 (08/10/18) - Initial release.","title":"Release Notes"},{"location":"api/","text":"TINerator API","title":"Index"},{"location":"api/#tinerator-api","text":"","title":"TINerator API"},{"location":"api/developernotes/","text":"For Developers Documentation Compilation Documentation is found in the tinerator/docs folder and is written in Markdown. The static site is generated by MkDocs using the Materials theme . Required MkDocs Extensions Package Command MathJax pip install pymdown-extensions Codehilite pip install pygments Materials theme pip install mkdocs-material Viewing the Site After all requirements are resolved, run mkdocs serve to start the local server. Navigate your web browser to the local server address (i.e., http://127.0.0.1:8000 ) to view. MkDocs will automatically reload the static site upon any detected file change within the docs/ folder. Site Deployment To deploy the site to GitHub pages, run null Note This manual process will eventually be phased out in support for TravisCI-based continuous deployment. Pull requests on this topic are welcome.","title":"For Developers"},{"location":"api/developernotes/#for-developers","text":"","title":"For Developers"},{"location":"api/developernotes/#documentation-compilation","text":"Documentation is found in the tinerator/docs folder and is written in Markdown. The static site is generated by MkDocs using the Materials theme .","title":"Documentation Compilation"},{"location":"api/developernotes/#required-mkdocs-extensions","text":"Package Command MathJax pip install pymdown-extensions Codehilite pip install pygments Materials theme pip install mkdocs-material","title":"Required MkDocs Extensions"},{"location":"api/developernotes/#viewing-the-site","text":"After all requirements are resolved, run mkdocs serve to start the local server. Navigate your web browser to the local server address (i.e., http://127.0.0.1:8000 ) to view. MkDocs will automatically reload the static site upon any detected file change within the docs/ folder.","title":"Viewing the Site"},{"location":"api/developernotes/#site-deployment","text":"To deploy the site to GitHub pages, run null Note This manual process will eventually be phased out in support for TravisCI-based continuous deployment. Pull requests on this topic are welcome.","title":"Site Deployment"},{"location":"tutorials/","text":"Tutorial Importing DEMs and Shapefiles insert image here insert description here Example 2 insert image here insert description here Example 3 insert image here insert description here","title":"Index"},{"location":"tutorials/#tutorial","text":"","title":"Tutorial"},{"location":"tutorials/#importing-dems-and-shapefiles","text":"insert image here insert description here","title":"Importing DEMs and Shapefiles"},{"location":"tutorials/#example-2","text":"insert image here insert description here","title":"Example 2"},{"location":"tutorials/#example-3","text":"insert image here insert description here","title":"Example 3"},{"location":"tutorials/attributes/","text":"Adding an Attribute Cell and node based attributes can be added to a stacked mesh - the attributes can be added either globally, across all layers, or local to one or more layers. Left: Soil map as read from an ASC file. Right: Soil map selectively applied to TIN layers. Reading and applying an attribute Basic syntax To add an attribute to a layered TIN, use the command: tinerator . DEM . addAttribute ( data , layers = [], dtype = int ) where layers is a list containing all layers to apply the attribute to, and dtype is the desired attribute type ( int or float ). As an example, consider a stacked mesh with three layers and an arbitrary floating point attribute. To apply that attribute only to the second layer: my_dem . addAttribute ( data , layers = [ 2 ], dtype = float ) By default, layers = None . This applies the attribute raster to every layer of the mesh. Note Any number of attribute rasters can be applied to a mesh, as long as each is given a unique name. Attribute Format Attributes must fundamentally be an N\\times M N\\times M Numpy matrix. The dimensions of the matrix do not necessarily have to be the same as those of the DEM. The data argument of addAttribute must be of type np.ndarray . To import or convert from popular file formats, a table of functions is given below. Click the function name to be redirected to its documentation. Data type Import function GIS rasters ( .asc , .tif , ...) gdal.Open(file) Plain-text matrix ( .txt , .dat , ...) numpy.loadtxt(file) Python list np.array(list) HDF5 ( .h5 ) h5py.File(file,'r') Note that when attributes are applied in TINerator, their domain spans that of the parent DEM. In other words, it is assumed that the data matrix has the same lower-left and upper-right corners as the DEM it is being applied to. Considering Data Types As mesh nodes will not necessarily align within cell centers of attribute raster, interpolation on that raster is performed. Based on the argument dtype , interpolation onto the mesh nodes will either be continuous ( float ) or nearest-neighbor ( int ). This is critical for properties such as soil ID, which only hold value as defined integers. Applying a function Assume that an attribute has been applied across all layers of the mesh. In some situations, it may be beneficial to change the attribute values based on the layer ID. The below method maps a user-defined function and operator onto mesh data: tinerator . DEM . mapFunctionToAttribute ( self , operator = '+' , layers = None , attribute_name = None , outfile = None , fn = lambda layer : layer * 100 ) In other words, the new attribute data will be a result of: A_{i,j}(layer) = A_{i,j} \\: [operation] \\: f(layer) \\: \\forall \\: i,j A_{i,j}(layer) = A_{i,j} \\: [operation] \\: f(layer) \\: \\forall \\: i,j where A_{i,j} A_{i,j} is the attribute raster data at index i,j i,j . Example Assume that we have soil types with unique values [1,3,5,10,12...] , applied to all layers of some mesh. To better define, say, porosity as a function of layer in our simulation, we would like to prefix each value with the layer ID. In other words, changing layer 1: [1,3,5,10,12...] layer 2: [1,3,5,10,12...] layer 3: [1,3,5,10,12...] ... to layer 1: [101,103,105,110,112...] layer 2: [201,203,205,210,212...] layer 3: [301,103,305,310,312...] ... This can be accomplished by using the following function: A_{i,j}(layer) = A_{i,j} + 100 \\cdot layer \\: \\forall \\: i,j A_{i,j}(layer) = A_{i,j} + 100 \\cdot layer \\: \\forall \\: i,j That is, adding 100 \\cdot layer_{ID} 100 \\cdot layer_{ID} to every attribute data point. Consequently, we want the operator to be + + and f(layer) = 100 \\cdot layer f(layer) = 100 \\cdot layer , or, my_dem . mapFunctionToAttribute ( attribute_name = 'exampleAttribute' , operator = '+' , fn = lambda layer : layer * 100 )","title":"Adding an Attribute"},{"location":"tutorials/attributes/#adding-an-attribute","text":"Cell and node based attributes can be added to a stacked mesh - the attributes can be added either globally, across all layers, or local to one or more layers. Left: Soil map as read from an ASC file. Right: Soil map selectively applied to TIN layers.","title":"Adding an Attribute"},{"location":"tutorials/attributes/#reading-and-applying-an-attribute","text":"","title":"Reading and applying an attribute"},{"location":"tutorials/attributes/#basic-syntax","text":"To add an attribute to a layered TIN, use the command: tinerator . DEM . addAttribute ( data , layers = [], dtype = int ) where layers is a list containing all layers to apply the attribute to, and dtype is the desired attribute type ( int or float ). As an example, consider a stacked mesh with three layers and an arbitrary floating point attribute. To apply that attribute only to the second layer: my_dem . addAttribute ( data , layers = [ 2 ], dtype = float ) By default, layers = None . This applies the attribute raster to every layer of the mesh. Note Any number of attribute rasters can be applied to a mesh, as long as each is given a unique name.","title":"Basic syntax"},{"location":"tutorials/attributes/#attribute-format","text":"Attributes must fundamentally be an N\\times M N\\times M Numpy matrix. The dimensions of the matrix do not necessarily have to be the same as those of the DEM. The data argument of addAttribute must be of type np.ndarray . To import or convert from popular file formats, a table of functions is given below. Click the function name to be redirected to its documentation. Data type Import function GIS rasters ( .asc , .tif , ...) gdal.Open(file) Plain-text matrix ( .txt , .dat , ...) numpy.loadtxt(file) Python list np.array(list) HDF5 ( .h5 ) h5py.File(file,'r') Note that when attributes are applied in TINerator, their domain spans that of the parent DEM. In other words, it is assumed that the data matrix has the same lower-left and upper-right corners as the DEM it is being applied to.","title":"Attribute Format"},{"location":"tutorials/attributes/#considering-data-types","text":"As mesh nodes will not necessarily align within cell centers of attribute raster, interpolation on that raster is performed. Based on the argument dtype , interpolation onto the mesh nodes will either be continuous ( float ) or nearest-neighbor ( int ). This is critical for properties such as soil ID, which only hold value as defined integers.","title":"Considering Data Types"},{"location":"tutorials/attributes/#applying-a-function","text":"Assume that an attribute has been applied across all layers of the mesh. In some situations, it may be beneficial to change the attribute values based on the layer ID. The below method maps a user-defined function and operator onto mesh data: tinerator . DEM . mapFunctionToAttribute ( self , operator = '+' , layers = None , attribute_name = None , outfile = None , fn = lambda layer : layer * 100 ) In other words, the new attribute data will be a result of: A_{i,j}(layer) = A_{i,j} \\: [operation] \\: f(layer) \\: \\forall \\: i,j A_{i,j}(layer) = A_{i,j} \\: [operation] \\: f(layer) \\: \\forall \\: i,j where A_{i,j} A_{i,j} is the attribute raster data at index i,j i,j .","title":"Applying a function"},{"location":"tutorials/attributes/#example","text":"Assume that we have soil types with unique values [1,3,5,10,12...] , applied to all layers of some mesh. To better define, say, porosity as a function of layer in our simulation, we would like to prefix each value with the layer ID. In other words, changing layer 1: [1,3,5,10,12...] layer 2: [1,3,5,10,12...] layer 3: [1,3,5,10,12...] ... to layer 1: [101,103,105,110,112...] layer 2: [201,203,205,210,212...] layer 3: [301,103,305,310,312...] ... This can be accomplished by using the following function: A_{i,j}(layer) = A_{i,j} + 100 \\cdot layer \\: \\forall \\: i,j A_{i,j}(layer) = A_{i,j} + 100 \\cdot layer \\: \\forall \\: i,j That is, adding 100 \\cdot layer_{ID} 100 \\cdot layer_{ID} to every attribute data point. Consequently, we want the operator to be + + and f(layer) = 100 \\cdot layer f(layer) = 100 \\cdot layer , or, my_dem . mapFunctionToAttribute ( attribute_name = 'exampleAttribute' , operator = '+' , fn = lambda layer : layer * 100 )","title":"Example"},{"location":"tutorials/basics/","text":"Importing DEMs and GIS data The DEM class structure After reading or downloading a DEM, an object of type tinerator.DEM is returned. This class contains all information related to tinning a particular GIS object: GIS data, such as the DEM matrix and shapefile polygons, meshing data, spatial data, and more. Further information on this class can be found by reading the API Documentation . The DEM - and associated metadata - is stored in the tinerator.DEM.dem attribute, which itself is a richdem.rdarray object: >>> print ( my_dem . dem . __dict__ ) { 'metadata' : { 'PROCESSING_HISTORY' : ' \\n 2019-01-23 18:53:20.598492 UTC | RichDEM (Python 0.3.4) (hash=\"ee05922\", hashdate=\"2018-07-13 13:01:09 -0700\") | LoadGDAL(filename=data/dem.asc, no_data=-9999.0)' }, 'no_data' : - 9999.0 , 'projection' : '' , 'geotransform' : ( 0.0 , 10.0 , 0.0 , 7510.0 , 0.0 , - 10.0 ) } Upon load, this metadata is parsed into specific tinerator.DEM variables. It is unlikely an end-user will need access to this RichDEM metadata. Reading DEMs Reading a DEM by file Reading a DEM via file is simply called by: my_dem = tinerator . loadDEM ( \"data/dem.asc\" ) The loading function uses GDAL as the I/O driver. Supported input filetypes can be found here . To verify import integrity, we can then plot the DEM and print metadata: my_dem . plot () print ( \"NODATAVALUE: {0} \\n Lower-left Corner: ({1},{2}) \\n Cell Size: {3}\" . format ( my_dem . no_data_value , my_dem . xll_corner , my_dem . yll_corner , my_dem . cell_size ) ) >>> NODATAVALUE: -9999.0 >>> Lower-left Corner: (0.0,0.0) >>> Cell Size: 10.0 Each of these metadata values are mutable and can be changed as circumstances dictate. Downloading from coordinates To download an SRTM 90m DEM by through a latitude / longitude bounding box, my_dem = tinerator . downloadDEM ( bounds = ( 12.35 , 41.8 , 12.65 , 42 ), outfile = 'Rome-90m-DEM.tif' ) where bounds is the bounding box values in geodetic coordinates (left, bottom, right, top), and outfile is an optional filepath to save the DEM. In this example, (12.35,41.8,12.65,42) represents a subsection of Rome: Downloading by Shapefile To download an SRTM 90m DEM through a Shapefile ( .shp ), my_dem = tinerator . downloadDEM ( shapefile = \"shapefile.shp\" , crop = True ) The argument crop replaces all areas of the DEM not covered by the shapefile with a NoDataValue. Setting crop = False will only return a DEM bound by the spatial domain of the shapefile. With crop = True : With crop = False : Applying a Shapefile Coming soon","title":"Importing DEMs"},{"location":"tutorials/basics/#importing-dems-and-gis-data","text":"","title":"Importing DEMs and GIS data"},{"location":"tutorials/basics/#the-dem-class-structure","text":"After reading or downloading a DEM, an object of type tinerator.DEM is returned. This class contains all information related to tinning a particular GIS object: GIS data, such as the DEM matrix and shapefile polygons, meshing data, spatial data, and more. Further information on this class can be found by reading the API Documentation . The DEM - and associated metadata - is stored in the tinerator.DEM.dem attribute, which itself is a richdem.rdarray object: >>> print ( my_dem . dem . __dict__ ) { 'metadata' : { 'PROCESSING_HISTORY' : ' \\n 2019-01-23 18:53:20.598492 UTC | RichDEM (Python 0.3.4) (hash=\"ee05922\", hashdate=\"2018-07-13 13:01:09 -0700\") | LoadGDAL(filename=data/dem.asc, no_data=-9999.0)' }, 'no_data' : - 9999.0 , 'projection' : '' , 'geotransform' : ( 0.0 , 10.0 , 0.0 , 7510.0 , 0.0 , - 10.0 ) } Upon load, this metadata is parsed into specific tinerator.DEM variables. It is unlikely an end-user will need access to this RichDEM metadata.","title":"The DEM class structure"},{"location":"tutorials/basics/#reading-dems","text":"","title":"Reading DEMs"},{"location":"tutorials/basics/#reading-a-dem-by-file","text":"Reading a DEM via file is simply called by: my_dem = tinerator . loadDEM ( \"data/dem.asc\" ) The loading function uses GDAL as the I/O driver. Supported input filetypes can be found here . To verify import integrity, we can then plot the DEM and print metadata: my_dem . plot () print ( \"NODATAVALUE: {0} \\n Lower-left Corner: ({1},{2}) \\n Cell Size: {3}\" . format ( my_dem . no_data_value , my_dem . xll_corner , my_dem . yll_corner , my_dem . cell_size ) ) >>> NODATAVALUE: -9999.0 >>> Lower-left Corner: (0.0,0.0) >>> Cell Size: 10.0 Each of these metadata values are mutable and can be changed as circumstances dictate.","title":"Reading a DEM by file"},{"location":"tutorials/basics/#downloading-from-coordinates","text":"To download an SRTM 90m DEM by through a latitude / longitude bounding box, my_dem = tinerator . downloadDEM ( bounds = ( 12.35 , 41.8 , 12.65 , 42 ), outfile = 'Rome-90m-DEM.tif' ) where bounds is the bounding box values in geodetic coordinates (left, bottom, right, top), and outfile is an optional filepath to save the DEM. In this example, (12.35,41.8,12.65,42) represents a subsection of Rome:","title":"Downloading from coordinates"},{"location":"tutorials/basics/#downloading-by-shapefile","text":"To download an SRTM 90m DEM through a Shapefile ( .shp ), my_dem = tinerator . downloadDEM ( shapefile = \"shapefile.shp\" , crop = True ) The argument crop replaces all areas of the DEM not covered by the shapefile with a NoDataValue. Setting crop = False will only return a DEM bound by the spatial domain of the shapefile. With crop = True : With crop = False :","title":"Downloading by Shapefile"},{"location":"tutorials/basics/#applying-a-shapefile","text":"Coming soon","title":"Applying a Shapefile"},{"location":"tutorials/facesets/","text":"Facesets Facesets use the Exodus ( pdf ) format.","title":"Defining FaceSets"},{"location":"tutorials/facesets/#facesets","text":"Facesets use the Exodus ( pdf ) format.","title":"Facesets"},{"location":"tutorials/meshing/","text":"Mesh Generation At this point, the DEM should be sufficiently post-processed, and we can begin the process of constructing a TIN. TIN generation is done in several discrete steps: Triplane (surface) generation Applying elevation to surface Extruding into defined layers Applying materials to layers Steps 1+2 and steps 3+4 are controlled with the following methods, respectively: tinerator . DEM . generateStackedTIN ( ** kwargs ) # Steps 1 & 2 tinerator . DEM . layeredMesh ( ** kwargs ) # Steps 3 & 4 Details on using these methods will be explained in the subsections below; for more information, read the method documentation . Building a Surface Mesh By default, TINerator will automatically determine whether to contruct a surface with refined or uniform triangles. If watershed delineation has not been performed, or the class variable tinerator.DEM.feature = None , then TINerator will generate a uniform surface. Otherwise, it will be refined. The generated surface mesh will maintain the same spatial domain as the parent DEM. This may cause overflow errors if the DEM domain is close to or exceeds the limit of a double-precision float. Uniform Once the boundary is generated, calculating a triplane is as simple as: my_dem . generateStackedTIN () The minimum edge length of the surface triangles will be equivalent to the spacing between adjacent boundary nodes, as defined in tinerator.DEM.generateBoundary() . To define a different edge length, use the method parameter min_edge : float , where the units of min_edge are the same units as the parent DEM. By default, DEM elevation data will be continuously interpolated onto the Z-values of the surface triangles. A completely flat mesh can be constructed instead with the method argument apply_elevation = False . Refined For generating a refined surface, call the method: my_dem . generateStackedTIN ( min_edge ) where min_edge will be the shortest edge generated in the refining process. This method works by (i) coarsely triangulating the interior of the boundary, and (ii) adaptively refining triangles according to a gradient field. The gradient field is a raster with values that scale relative to the Euclidean distance from the feature. Triangle edge length scales linearly from min_edge , where the gradient field is 0 (at the feature), towards max_edge , where the gradient field is 1 (at the edge of the DEM domain), according to this equation: e(i,j) = e_{min} + \\left( e_{max} - e_{min} \\right) \\cdot \\nabla D(i,j) e(i,j) = e_{min} + \\left( e_{max} - e_{min} \\right) \\cdot \\nabla D(i,j) As stated above, DEM elevation data will be interpolated onto the Z-coordinate of the surface nodes unless explicitly defined otherwise. Mesh Quality Triangulation is done with a Delaunay triangulation algorithm, and the mesh is iteratively smoothed with Laplacian smoothing . The number of smoothing / reconnection iterations can be controlled with the keyword iterations : int . Mesh quality can be found through the method: tinerator . DEM . quality ( 'surface' ) This returns a dictionary containing aspect ratio statistics ( \\theta_{max} / \\theta_{min} \\theta_{max} / \\theta_{min} ), edge length ratio statistics ( e_{max} / e_{min} e_{max} / e_{min} ), and count of malformed elements (triangles with very large angles, very small angles, or very small areas). Stacking the Mesh Mesh extrusion is the process of extruding a triangular surface mesh into a volumetric prism mesh. This method is called using tinerator . DEM . layeredMesh ( ** kwargs ) For more information, see the documentation . As an example, after generating a triangular surface mesh, it can be layered by: layers = [ 0.1 , 0.3 , 0.6 , 8. , 21. ] # Define layer thickness matids = [ 1 , 2 , 3 , 4 , 5 ] # Define material ID my_dem . layeredMesh ( layers , matids = matids ) where layers is a list of length N , containing the sequential depths of layers to extrude, and matids is a list of length N containing the sequential integer IDs for each layer. For example, layer 1 will have a depth of 0.1 meters and a material ID of 1, layer 2 will have a depth of 0.3 and a material ID of 2, and so on. Note The length of list layers must equal the length of list matids Layers Depending on your particular use case, you may want as few as one layer, or many more. Layers may be of any arbitrary thickness, with units the same as the DEM parent. Note that the number of elements in the volumetric mesh, N_{volume} N_{volume} , is directly proportional to the number of layers n_{layers} n_{layers} : N_{volume} = N_{surface} \\cdot n_{layers} N_{volume} = N_{surface} \\cdot n_{layers} Five-layer prism mesh. Layer depths have been strongly exaggerated for effect. Materials Each layer can optionally have its own material ID - this provides an easy way to identify which layer an element is in, or to find elements within a defined layer. Note that material ID is not necessarily an attribute - it is a non-zero integer value mapped to an element. Cell and node based attributes are applied using a different process - read more here . An exaggerated view of layers colored by material ID. Note that some values are unique to its layer, while other layers share an ID.","title":"Generating a Mesh"},{"location":"tutorials/meshing/#mesh-generation","text":"At this point, the DEM should be sufficiently post-processed, and we can begin the process of constructing a TIN. TIN generation is done in several discrete steps: Triplane (surface) generation Applying elevation to surface Extruding into defined layers Applying materials to layers Steps 1+2 and steps 3+4 are controlled with the following methods, respectively: tinerator . DEM . generateStackedTIN ( ** kwargs ) # Steps 1 & 2 tinerator . DEM . layeredMesh ( ** kwargs ) # Steps 3 & 4 Details on using these methods will be explained in the subsections below; for more information, read the method documentation .","title":"Mesh Generation"},{"location":"tutorials/meshing/#building-a-surface-mesh","text":"By default, TINerator will automatically determine whether to contruct a surface with refined or uniform triangles. If watershed delineation has not been performed, or the class variable tinerator.DEM.feature = None , then TINerator will generate a uniform surface. Otherwise, it will be refined. The generated surface mesh will maintain the same spatial domain as the parent DEM. This may cause overflow errors if the DEM domain is close to or exceeds the limit of a double-precision float.","title":"Building a Surface Mesh"},{"location":"tutorials/meshing/#uniform","text":"Once the boundary is generated, calculating a triplane is as simple as: my_dem . generateStackedTIN () The minimum edge length of the surface triangles will be equivalent to the spacing between adjacent boundary nodes, as defined in tinerator.DEM.generateBoundary() . To define a different edge length, use the method parameter min_edge : float , where the units of min_edge are the same units as the parent DEM. By default, DEM elevation data will be continuously interpolated onto the Z-values of the surface triangles. A completely flat mesh can be constructed instead with the method argument apply_elevation = False .","title":"Uniform"},{"location":"tutorials/meshing/#refined","text":"For generating a refined surface, call the method: my_dem . generateStackedTIN ( min_edge ) where min_edge will be the shortest edge generated in the refining process. This method works by (i) coarsely triangulating the interior of the boundary, and (ii) adaptively refining triangles according to a gradient field. The gradient field is a raster with values that scale relative to the Euclidean distance from the feature. Triangle edge length scales linearly from min_edge , where the gradient field is 0 (at the feature), towards max_edge , where the gradient field is 1 (at the edge of the DEM domain), according to this equation: e(i,j) = e_{min} + \\left( e_{max} - e_{min} \\right) \\cdot \\nabla D(i,j) e(i,j) = e_{min} + \\left( e_{max} - e_{min} \\right) \\cdot \\nabla D(i,j) As stated above, DEM elevation data will be interpolated onto the Z-coordinate of the surface nodes unless explicitly defined otherwise.","title":"Refined"},{"location":"tutorials/meshing/#mesh-quality","text":"Triangulation is done with a Delaunay triangulation algorithm, and the mesh is iteratively smoothed with Laplacian smoothing . The number of smoothing / reconnection iterations can be controlled with the keyword iterations : int . Mesh quality can be found through the method: tinerator . DEM . quality ( 'surface' ) This returns a dictionary containing aspect ratio statistics ( \\theta_{max} / \\theta_{min} \\theta_{max} / \\theta_{min} ), edge length ratio statistics ( e_{max} / e_{min} e_{max} / e_{min} ), and count of malformed elements (triangles with very large angles, very small angles, or very small areas).","title":"Mesh Quality"},{"location":"tutorials/meshing/#stacking-the-mesh","text":"Mesh extrusion is the process of extruding a triangular surface mesh into a volumetric prism mesh. This method is called using tinerator . DEM . layeredMesh ( ** kwargs ) For more information, see the documentation . As an example, after generating a triangular surface mesh, it can be layered by: layers = [ 0.1 , 0.3 , 0.6 , 8. , 21. ] # Define layer thickness matids = [ 1 , 2 , 3 , 4 , 5 ] # Define material ID my_dem . layeredMesh ( layers , matids = matids ) where layers is a list of length N , containing the sequential depths of layers to extrude, and matids is a list of length N containing the sequential integer IDs for each layer. For example, layer 1 will have a depth of 0.1 meters and a material ID of 1, layer 2 will have a depth of 0.3 and a material ID of 2, and so on. Note The length of list layers must equal the length of list matids","title":"Stacking the Mesh"},{"location":"tutorials/meshing/#layers","text":"Depending on your particular use case, you may want as few as one layer, or many more. Layers may be of any arbitrary thickness, with units the same as the DEM parent. Note that the number of elements in the volumetric mesh, N_{volume} N_{volume} , is directly proportional to the number of layers n_{layers} n_{layers} : N_{volume} = N_{surface} \\cdot n_{layers} N_{volume} = N_{surface} \\cdot n_{layers} Five-layer prism mesh. Layer depths have been strongly exaggerated for effect.","title":"Layers"},{"location":"tutorials/meshing/#materials","text":"Each layer can optionally have its own material ID - this provides an easy way to identify which layer an element is in, or to find elements within a defined layer. Note that material ID is not necessarily an attribute - it is a non-zero integer value mapped to an element. Cell and node based attributes are applied using a different process - read more here . An exaggerated view of layers colored by material ID. Note that some values are unique to its layer, while other layers share an ID.","title":"Materials"},{"location":"tutorials/watershed/","text":"Preparing the DEM One of the most powerful features of TINerator is the ability to create meshes which are variably refined around some DEM feature, such as a river or stream network. To prepare the DEM for mesh generation, a feature needs to be (optionally) defined, and a boundary generated. Note that an option in TINerator exists to generate a mesh without feature refinement - see the mesh generation section for more information. Watershed Delineation Defining a river or stream network ('feature') in the DEM is done through the command: my_dem . watershedDelineation ( threshold = 4500. , plot = False , spacing = 30. ) Performing a watershed delineation is a multi-step process: Depressions ('pits') are filled Flats are resolved Flow accumulation is performed Resolving Depressions and Flats Source: Lindsay, John. (2015). Efficient hybrid breaching-filling sink removal methods for flow path enforcement in digital elevation models. Hydrological Processes. 30. 846\u2013857. doi: 10.1002/hyp.10648 . Flow accumulation algorithms are numerous , but they all tend to operate relative to elevation deltas between adjacent DEM cells. Consequently, flats and pits can disrupt accumulation algorithms, causing premature termination of the flow patterns. It is therefore, in general, best to preprocess a DEM to remove depressions and flats. Depressions and flats identified and removed on a standard DEM Flat and pit resolution is the default behavior of the watershedDelineation function. For more information on better controlling these steps, refer to the API Documentation . The DEM feature will be found in the class variable tinerator.DEM.feature , and is an N-by-2 np.ndarray defining a polyline. Flow accumulation A critical step in determining river networks is through flow accumulation algorithms. These algorithms generate a raster of accumulated flow by accumulating the weight of all cells that flow into adjacent cells with a negative elevation data ('downslope cells'). Source: ArcGis Pro, How Flow Accumulation works TINerator supports a number of popular flow accumulation algorithms: D8 D4 D-Infinity Rho8 Rho4 Quinn Freeman Holmgren By default, D8 is used. For more information on these different algorithms, visit the RichDEM Flow Metrics page . After flow accumulation is performed, the feature can be extracted by setting an accumulation threshold and defining all cells above that threshold to be a part of the feature. As an example, see the below figure: Left: Flow accumulation intensity. Right: Feature pulled by thresholding the flow accumulation matrix. On the left, the raster generated by the flow accumulation algorithm is displayed. Note that effectively all non-masked cells in the DEM have some non-zero amount of accumulation. By settings threshold = 0. , effectively the entire DEM would be 'captured' as a feature. Note that, if you only consider cells with more than 10^4 10^4 accumulations, a river network becomes visible. Consequently, the threshold should be set to reflect that. Here, threshold = 4.5E10 , and the feature derived from setting that threshold value is shown on the right of the figure. Note The optimal threshold value will change for each distinct DEM. Pay careful attention to set a value relative to your workflow goals. Boundary Generation Boundary generation is done using a Square Tracing Algorithm to quickly capture the perimeter of the DEM. The boundary is defined as the interface between cells with NoDataValue entries ( z_{i,j} = NDV z_{i,j} = NDV ) and cells with data ( z_{i,j} \\ne NDV z_{i,j} \\ne NDV ). For DEMs that do not have cells with NoDataValue elements ( z(i,j) \\cap NDV = \\emptyset z(i,j) \\cap NDV = \\emptyset ), a rectangular boundary spanning the domain of the DEM is generated instead. The boundary is generated with the method tinerator . DEM . generateBoundary ( delta : float ) where delta is the spacing between adjacent boundary nodes. The units of delta will be the same as the units of the parent DEM. Warning Boundary generation must be done before proceeding to mesh generation. As an example, my_dem . generateBoundary ( 100. ) my_dem . plotBoundary () will generate (and plot) a boundary with 100 meter spacing. The boundary array is mutable and can be found in the class variable tinerator.DEM.boundary .","title":"Preparing the DEM"},{"location":"tutorials/watershed/#preparing-the-dem","text":"One of the most powerful features of TINerator is the ability to create meshes which are variably refined around some DEM feature, such as a river or stream network. To prepare the DEM for mesh generation, a feature needs to be (optionally) defined, and a boundary generated. Note that an option in TINerator exists to generate a mesh without feature refinement - see the mesh generation section for more information.","title":"Preparing the DEM"},{"location":"tutorials/watershed/#watershed-delineation","text":"Defining a river or stream network ('feature') in the DEM is done through the command: my_dem . watershedDelineation ( threshold = 4500. , plot = False , spacing = 30. ) Performing a watershed delineation is a multi-step process: Depressions ('pits') are filled Flats are resolved Flow accumulation is performed","title":"Watershed Delineation"},{"location":"tutorials/watershed/#resolving-depressions-and-flats","text":"Source: Lindsay, John. (2015). Efficient hybrid breaching-filling sink removal methods for flow path enforcement in digital elevation models. Hydrological Processes. 30. 846\u2013857. doi: 10.1002/hyp.10648 . Flow accumulation algorithms are numerous , but they all tend to operate relative to elevation deltas between adjacent DEM cells. Consequently, flats and pits can disrupt accumulation algorithms, causing premature termination of the flow patterns. It is therefore, in general, best to preprocess a DEM to remove depressions and flats. Depressions and flats identified and removed on a standard DEM Flat and pit resolution is the default behavior of the watershedDelineation function. For more information on better controlling these steps, refer to the API Documentation . The DEM feature will be found in the class variable tinerator.DEM.feature , and is an N-by-2 np.ndarray defining a polyline.","title":"Resolving Depressions and Flats"},{"location":"tutorials/watershed/#flow-accumulation","text":"A critical step in determining river networks is through flow accumulation algorithms. These algorithms generate a raster of accumulated flow by accumulating the weight of all cells that flow into adjacent cells with a negative elevation data ('downslope cells'). Source: ArcGis Pro, How Flow Accumulation works TINerator supports a number of popular flow accumulation algorithms: D8 D4 D-Infinity Rho8 Rho4 Quinn Freeman Holmgren By default, D8 is used. For more information on these different algorithms, visit the RichDEM Flow Metrics page . After flow accumulation is performed, the feature can be extracted by setting an accumulation threshold and defining all cells above that threshold to be a part of the feature. As an example, see the below figure: Left: Flow accumulation intensity. Right: Feature pulled by thresholding the flow accumulation matrix. On the left, the raster generated by the flow accumulation algorithm is displayed. Note that effectively all non-masked cells in the DEM have some non-zero amount of accumulation. By settings threshold = 0. , effectively the entire DEM would be 'captured' as a feature. Note that, if you only consider cells with more than 10^4 10^4 accumulations, a river network becomes visible. Consequently, the threshold should be set to reflect that. Here, threshold = 4.5E10 , and the feature derived from setting that threshold value is shown on the right of the figure. Note The optimal threshold value will change for each distinct DEM. Pay careful attention to set a value relative to your workflow goals.","title":"Flow accumulation"},{"location":"tutorials/watershed/#boundary-generation","text":"Boundary generation is done using a Square Tracing Algorithm to quickly capture the perimeter of the DEM. The boundary is defined as the interface between cells with NoDataValue entries ( z_{i,j} = NDV z_{i,j} = NDV ) and cells with data ( z_{i,j} \\ne NDV z_{i,j} \\ne NDV ). For DEMs that do not have cells with NoDataValue elements ( z(i,j) \\cap NDV = \\emptyset z(i,j) \\cap NDV = \\emptyset ), a rectangular boundary spanning the domain of the DEM is generated instead. The boundary is generated with the method tinerator . DEM . generateBoundary ( delta : float ) where delta is the spacing between adjacent boundary nodes. The units of delta will be the same as the units of the parent DEM. Warning Boundary generation must be done before proceeding to mesh generation. As an example, my_dem . generateBoundary ( 100. ) my_dem . plotBoundary () will generate (and plot) a boundary with 100 meter spacing. The boundary array is mutable and can be found in the class variable tinerator.DEM.boundary .","title":"Boundary Generation"}]}